<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>EmacsWiki: color-moccur.el</title><link rel="alternate" type="application/wiki" title="Edit this page" href="https://www.emacswiki.org/emacs?action=edit;id=color-moccur.el" /><link type="text/css" rel="stylesheet" href="/light.css" /><meta name="robots" content="INDEX,FOLLOW" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki" href="https://www.emacswiki.org/emacs?action=rss" /><link rel="alternate" type="application/rss+xml" title="EmacsWiki: color-moccur.el" href="https://www.emacswiki.org/emacs?action=rss;rcidonly=color-moccur.el" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content"
      href="https://www.emacswiki.org/full.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki with page content and diff"
      href="https://www.emacswiki.org/full-diff.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Emacs Wiki including minor differences"
      href="https://www.emacswiki.org/minor-edits.rss" />
<link rel="alternate" type="application/rss+xml"
      title="Changes for color-moccur.el only"
      href="https://www.emacswiki.org/emacs?action=rss;rcidonly=color-moccur.el" /><meta name="viewport" content="width=device-width" />
<script type="text/javascript" src="/outliner.0.5.0.62-toc.js"></script>
<script type="text/javascript">

  function addOnloadEvent(fnc) {
    if ( typeof window.addEventListener != "undefined" )
      window.addEventListener( "load", fnc, false );
    else if ( typeof window.attachEvent != "undefined" ) {
      window.attachEvent( "onload", fnc );
    }
    else {
      if ( window.onload != null ) {
	var oldOnload = window.onload;
	window.onload = function ( e ) {
	  oldOnload( e );
	  window[fnc]();
	};
      }
      else
	window.onload = fnc;
    }
  }

  // https://stackoverflow.com/questions/280634/endswith-in-javascript
  if (typeof String.prototype.endsWith !== 'function') {
    String.prototype.endsWith = function(suffix) {
      return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
  }

  var initToc=function() {

    var outline = HTML5Outline(document.body);
    if (outline.sections.length == 1) {
      outline.sections = outline.sections[0].sections;
    }

    if (outline.sections.length > 1
	|| outline.sections.length == 1
           && outline.sections[0].sections.length > 0) {

      var toc = document.getElementById('toc');

      if (!toc) {
	var divs = document.getElementsByTagName('div');
	for (var i = 0; i < divs.length; i++) {
	  if (divs[i].getAttribute('class') == 'toc') {
	    toc = divs[i];
	    break;
	  }
	}
      }

      if (!toc) {
	var h2 = document.getElementsByTagName('h2')[0];
	if (h2) {
	  toc = document.createElement('div');
	  toc.setAttribute('class', 'toc');
	  h2.parentNode.insertBefore(toc, h2);
	}
      }

      if (toc) {
        var html = outline.asHTML(true);
        toc.innerHTML = html;

	items = toc.getElementsByTagName('a');
	for (var i = 0; i < items.length; i++) {
	  while (items[i].textContent.endsWith('âœŽ')) {
            var text = items[i].childNodes[0].nodeValue;
	    items[i].childNodes[0].nodeValue = text.substring(0, text.length - 1);
	  }
	}
      }
    }
  }

  addOnloadEvent(initToc);
  </script>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /></head><body class="default"><div class="header"><a class="logo" href="https://www.emacswiki.org/emacs/SiteMap"><img alt="[Home]" src="/emacs_logo.png" class="logo" /></a><div class="menu"><span class="gotobar bar"><a class="local" href="https://www.emacswiki.org/emacs/SiteMap">SiteMap</a> <a href="https://www.emacswiki.org/emacs/Search" class="local">Search</a> <a class="local" href="https://www.emacswiki.org/emacs/ElispArea">ElispArea</a> <a class="local" href="https://www.emacswiki.org/emacs/HowTo">HowTo</a> <a href="https://www.emacswiki.org/emacs/Glossary" class="local">Glossary</a> <a class="local" href="https://www.emacswiki.org/emacs/RecentChanges">RecentChanges</a> <a class="local" href="https://www.emacswiki.org/emacs/News">News</a> <a href="https://www.emacswiki.org/emacs/Problems" class="local">Problems</a> <a href="https://www.emacswiki.org/emacs/Suggestions" class="local">Suggestions</a> </span><form method="get" action="https://www.emacswiki.org/emacs" enctype="multipart/form-data" class="search" accept-charset="utf-8"><p><label for="search">Search:</label> <input type="text" name="search"  size="20" accesskey="f" id="search" /> <label for="searchlang">Language:</label> <input type="text" name="lang"  size="10" id="searchlang" /> <input type="submit" name="dosearch" value="Go!" /></p></form></div><h1><a title="Click to search for references to this page" href="https://www.emacswiki.org/emacs?search=%22color-moccur%5c.el%22" rel="nofollow">color-moccur.el</a></h1></div><div class="wrapper"><div class="content browse"><p class="download"><a href="http://www.emacswiki.org/emacs/download/color-moccur.el">Download</a></p><pre><span class="comment">;;; color-moccur.el ---  multi-buffer occur (grep) mode</span>
<span class="comment">;; -*- Mode: Emacs-Lisp -*-</span>

<span class="comment">;; $Id: color-moccur.el,v 2.71 2010-05-06 13:40:54 Akihisa Exp $</span>

<span class="comment">;; This program is free software; you can redistribute it and/or</span>
<span class="comment">;; modify it under the terms of the GNU General Public License as</span>
<span class="comment">;; published by the Free Software Foundation; either version 3, or (at</span>
<span class="comment">;; your option) any later version.</span>

<span class="comment">;; This program is distributed in the hope that it will be useful, but</span>
<span class="comment">;; WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="comment">;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="comment">;; General Public License for more details.</span>

<span class="comment">;; You should have received a copy of the GNU General Public License</span>
<span class="comment">;; along with GNU Emacs; see the file COPYING.  If not, write to the</span>
<span class="comment">;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,</span>
<span class="comment">;; Boston, MA 02110-1301, USA.</span>

<span class="comment">;;;; for hi-lock</span>
<span class="comment">;; Hi-lock: ((<span class="string">"^;;; .*"</span> (0 (quote hi-black-hb) t)))</span>
<span class="comment">;; Hi-lock: ((<span class="string">"^;;;; .*"</span> (0 (quote hi-black-b) t)))</span>
<span class="comment">;; Hi-lock: ((<span class="string">"make-variable-buffer-\\(local\\)"</span> (0 font-lock-keyword-face)(1 'italic append)))</span>
<span class="comment">;; Hi-lock: end</span>

<span class="comment">;;; Commentary<span class="builtin">:</span></span>
<span class="comment">;; If this program doesn't run, I might change the program for the</span>
<span class="comment">;; worse.  So please send mail to akihisa@mail.ne.jp .</span>

<span class="comment">;; This elisp is the extention of moccur.el.</span>
<span class="comment">;; Thanks to the authors for writing moccur.el</span>

<span class="comment">;; With color-moccur, you can search a regexp in all buffers. And you</span>
<span class="comment">;; can search files like grep(-find) without grep (and find) command.</span>

<span class="comment">;;; Motivation</span>
<span class="comment">;; moccur is a major mode modelled after the 'Occur' mode of the</span>
<span class="comment">;; standard distribution. It is quite nice to use when you need to</span>
<span class="comment">;; work with a lot of buffers.</span>
<span class="comment">;;</span>
<span class="comment">;; Incompatibilites to Occur mode<span class="builtin">:</span></span>
<span class="comment">;; a) it browses through *all* buffers that have a file name</span>
<span class="comment">;; associated with them; those may or may not include the current</span>
<span class="comment">;; buffer. Especially, while standard occur works</span>
<span class="comment">;; on 'all lines following point', Moccur does not.</span>
<span class="comment">;; b) there is no support for the 'NLINE' argument.</span>

<span class="comment">;;; Install<span class="builtin">:</span></span>
<span class="comment">;; Put this file into load-path'ed directory, and byte compile it if</span>
<span class="comment">;; desired.  And put the following expression into your ~/.emacs.</span>
<span class="comment">;;</span>
<span class="comment">;;     (<span class="keyword">require</span> '<span class="constant">color-moccur</span>)</span>

<span class="comment">;; The latest version of this program can be downloaded from</span>
<span class="comment">;; http<span class="builtin">://www</span>.bookshelf.jp/elc/color-moccur.el</span>

<span class="comment">;; moccur-edit.el</span>
<span class="comment">;;   With this packege, you can edit *moccur* buffer and apply</span>
<span class="comment">;;   the changes to the files.</span>
<span class="comment">;;   You can get moccur-edit.el at</span>
<span class="comment">;;   http<span class="builtin">://www</span>.bookshelf.jp/elc/moccur-edit.el</span>

<span class="comment">;;; Functions</span>
<span class="comment">;; moccur, dmoccur, dired-do-moccur, Buffer-menu-moccur,</span>
<span class="comment">;; grep-buffers, search-buffers, occur-by-moccur</span>
<span class="comment">;; isearch-moccur</span>
<span class="comment">;; moccur-grep, moccur-grep-find</span>

<span class="comment">;;; usage<span class="builtin">:moccur</span></span>
<span class="comment">;; moccur &lt;regexp&gt; shows all occurrences of &lt;regexp&gt; in all buffers</span>
<span class="comment">;; currently existing that refer to files.</span>
<span class="comment">;; The occurrences are displayed in a buffer running in Moccur mode;</span>
<span class="comment">;;;; keybind</span>
<span class="comment">;; C-c C-c or RET gets you to the occurrence</span>
<span class="comment">;; q : quit</span>
<span class="comment">;; &lt;up&gt;, n, j   : next matches</span>
<span class="comment">;; &lt;down&gt;, p, k : previous matches</span>
<span class="comment">;; b <span class="builtin">:scroll-down</span> in matched buffer</span>
<span class="comment">;; SPC : scroll-up in matched buffer</span>
<span class="comment">;; M-v <span class="builtin">:scroll-down</span> in moccur buffer</span>
<span class="comment">;; C-v : scroll-up in moccur buffer</span>
<span class="comment">;; &lt; : M-&lt; in matched buffer</span>
<span class="comment">;; &gt; : M-&gt; in matched buffer</span>
<span class="comment">;; t : toggle whether a searched buffer is displayed to other window.</span>
<span class="comment">;; r : re-search in only matched buffers.</span>
<span class="comment">;; d,C-k : kill-line</span>
<span class="comment">;; M-x moccur-flush-lines : flush-lines for moccur</span>
<span class="comment">;; M-x moccur-keep-lines : keep-lines for moccur</span>
<span class="comment">;; / : undo (maybe doesn't work)</span>
<span class="comment">;; s : run moccur by matched bufffer only.</span>
<span class="comment">;; u : run moccur by prev condition</span>

<span class="comment">;;; usage<span class="builtin">:moccur-grep</span>, moccur-grep-find</span>
<span class="comment">;; moccur-grep &lt;regexp&gt; shows all occurrences of &lt;regexp&gt; in files of current directory</span>
<span class="comment">;; moccur-grep-find &lt;regexp&gt; shows all occurrences of &lt;regexp&gt;</span>
<span class="comment">;;                  in files of current directory recursively.</span>
<span class="comment">;;</span>
<span class="comment">;;;; Variables of M-x moccur-grep(-find)</span>
<span class="comment">;; dmoccur-exclusion-mask : if filename matches the regular</span>
<span class="comment">;; expression, dmoccur/moccur-grep *doesn't* open the file.</span>
<span class="comment">;;</span>
<span class="comment">;; dmoccur-maximum-size: Maximum size (kB) of a buffer for dmoccur and</span>
<span class="comment">;; moccur-grep(-find).</span>
<span class="comment">;;</span>
<span class="comment">;; moccur-following-mode-toggle <span class="builtin">:</span></span>
<span class="comment">;; If this value is t, cursor motion in the moccur buffer causes</span>
<span class="comment">;; automatic display of the corresponding buffer location.</span>
<span class="comment">;;</span>
<span class="comment">;; moccur-grep-following-mode-toggle <span class="builtin">:</span></span>
<span class="comment">;; If this value is t, cursor motion in the moccur-grep buffer causes</span>
<span class="comment">;; automatic display of the corresponding source code location.</span>
<span class="comment">;;</span>
<span class="comment">;; moccur-grep-default-word-near-point <span class="builtin">:</span></span>
<span class="comment">;; If this value is t, moccur-grep(-find) command get a word near the</span>
<span class="comment">;; point as default regexp string</span>
<span class="comment">;;</span>
<span class="comment">;; moccur-grep-default-mask <span class="builtin">:</span></span>
<span class="comment">;; example in .emacs: (setq-default moccur-grep-default-mask <span class="string">".el"</span>)</span>
<span class="comment">;; File-mask string used for default in moccur-grep and moccur-grep-find</span>
<span class="comment">;; Run moccur-grep, and chose directory, in minibuffer, following text is displayed</span>
<span class="comment">;; Input Regexp and FileMask:  .el</span>

<span class="comment">;;; usage<span class="builtin">:isearch-moccur</span></span>
<span class="comment">;; isearch and M-o</span>
<span class="comment">;; Run `<span class="constant important">moccur</span>' with current isearch string.</span>
<span class="comment">;; isearch and M-O</span>
<span class="comment">;; Run `<span class="constant important">moccur</span>' with current isearch string in all buffers.</span>

<span class="comment">;;; usage<span class="builtin">:M-x</span> occur-by-moccur</span>
<span class="comment">;; suearch current buffer by moccur</span>

<span class="comment">;;; usage<span class="builtin">:Buffer-menu-moccur</span></span>
<span class="comment">;; `<span class="constant important">Buffer-menu-moccur</span>' command searches buffers marked in</span>
<span class="comment">;; buffer-menu or ibuffer.</span>

<span class="comment">;;; usage<span class="builtin">:dired-do-moccur</span></span>
<span class="comment">;; Search through all marked files in dired buffer.</span>

<span class="comment">;;; usage<span class="builtin">:search-buffers</span> &lt;regexp&gt;</span>
<span class="comment">;; junk tool. To search all buffers, type in</span>
<span class="comment">;; a few descriptive words like <span class="string">"setq gnus"</span> hit the 'enter' key.</span>
<span class="comment">;; This program only returns web pages that contain all the words in</span>
<span class="comment">;; your query. And Type RET in the result buffer to call moccur.</span>

<span class="comment">;;; usage<span class="builtin">:grep-buffers</span> &lt;regexp&gt;</span>
<span class="comment">;; Run grep on all visited files.</span>

<span class="comment">;;; usage<span class="builtin">:M-x</span> dmoccur</span>
<span class="comment">;; dmoccur opens files under current directory, and searches your</span>
<span class="comment">;; regular expression by moccur.</span>

<span class="comment">;;;; Variables of M-x dmoccur</span>
<span class="comment">;; dmoccur-mask : if filename matches the regular expression, dmoccur</span>
<span class="comment">;; opens the file.</span>
<span class="comment">;; dmoccur-exclusion-mask : if filename matches the regular</span>
<span class="comment">;; expression, dmoccur/moccur-grep *doesn't* open the file.</span>
<span class="comment">;; dmoccur-maximum-size : Only buffers less than this can be opend.</span>

<span class="comment">;;;; C-u M-x dmoccur</span>
<span class="comment">;; Probably you will search same directory many times. So dmoccur has</span>
<span class="comment">;; your favorite directory list. And if you input a name, dmoccur can</span>
<span class="comment">;; search files under a directory.</span>

<span class="comment">;;;; variable<span class="builtin">:dmoccur-mask</span></span>
<span class="comment">;; dmoccur-mask is masks for searched file. defult is (<span class="string">".*"</span>).</span>

<span class="comment">;;;; variable<span class="builtin">:dmoccur-maximum-size</span></span>
<span class="comment">;; Maximum size (kB) of a searched buffer by dmoccur.</span>

<span class="comment">;;;; variable<span class="builtin">:dmoccur-exclusion-mask</span></span>
<span class="comment">;; dmoccur-exclusion-mask is masks for *not* searched file by dmoccur and moccur-grep(-find).</span>

<span class="comment">;;;; Variables of C-u M-x dmoccur</span>
<span class="comment">;; dmoccur-list : Your favorite directory list. This valiable is used</span>
<span class="comment">;; as bellow.</span>

<span class="comment">;; (setq dmoccur-list</span>
<span class="comment">;;       '(</span>
<span class="comment">;;         ;;name    directory         mask               option</span>
<span class="comment">;;         (<span class="string">"dir"</span>    default-directory (<span class="string">".*"</span>)              dir)</span>
<span class="comment">;;         (<span class="string">"config"</span> <span class="string">"~/mylisp/"</span>       (<span class="string">"\\.js"</span> <span class="string">"\\.el$"</span>)  nil)</span>
<span class="comment">;;         (<span class="string">"multi"</span> ((<span class="string">"~/mylisp/"</span>)</span>
<span class="comment">;;                   (<span class="string">"~/lisp/"</span>))     (<span class="string">"\\.js"</span> <span class="string">"\\.el$"</span>)  nil)</span>
<span class="comment">;;         (<span class="string">"emacs"</span>  <span class="string">"d<span class="builtin">:/unix/emacs/</span>"</span>  (<span class="string">".*"</span>)              sub)</span>
<span class="comment">;;         ))</span>

<span class="comment">;; name : Input your favorite name</span>
<span class="comment">;; directory : Directory you'd like to search</span>
<span class="comment">;; mask : list of file-mask (regular expression).</span>
<span class="comment">;; option : usually option is nil. If option is <span class="string">"dir"</span>, you can select</span>
<span class="comment">;; directory like find-file. If option is <span class="string">"sub"</span>, you can select sub</span>
<span class="comment">;; directory.</span>

<span class="comment">;; Moreover you can also customize dmoccur-list as bellow.</span>
<span class="comment">;; (setq dmoccur-list</span>
<span class="comment">;;        '(</span>
<span class="comment">;;         ;; multi-directory can be setted if option is nil</span>
<span class="comment">;;         (<span class="string">"soft"</span></span>
<span class="comment">;;          (</span>
<span class="comment">;;           (<span class="string">"~/www/soft/"</span>)</span>
<span class="comment">;;           (<span class="string">"~/mylisp/"</span>)</span>
<span class="comment">;;           )</span>
<span class="comment">;;          (<span class="string">"\\.texi$"</span>) nil)</span>
<span class="comment">;;</span>
<span class="comment">;;          ;; In ~/mylisp, dmoccur search files recursively.</span>
<span class="comment">;;          ;; and dmoccur search files in ~/user.</span>
<span class="comment">;;          (<span class="string">"test-recursive"</span></span>
<span class="comment">;;           ((<span class="string">"~/mylisp"</span> t)</span>
<span class="comment">;;            (<span class="string">"~/user"</span>))</span>
<span class="comment">;;           (<span class="string">".*"</span>) nil)</span>
<span class="comment">;;</span>
<span class="comment">;;          ;; In ~/mylisp, dmoccur search files recursively</span>
<span class="comment">;;          ;; but if (string-match <span class="string">".+.txt"</span> filename)</span>
<span class="comment">;;          ;; or (string-match <span class="string">".+.el"</span> filename) is t,</span>
<span class="comment">;;          ;; the file is *not* searched.</span>
<span class="comment">;;          (<span class="string">"ignore-txt"</span></span>
<span class="comment">;;           ((<span class="string">"~/mylisp"</span> t (<span class="string">".+.txt"</span> <span class="string">".+.el"</span>))</span>
<span class="comment">;;            (<span class="string">"~/user"</span>))</span>
<span class="comment">;;           (<span class="string">".*"</span>) nil)</span>
<span class="comment">;;</span>
<span class="comment">;;          ;; if option is dir (or sub),</span>
<span class="comment">;;          ;; you can set single directory only.</span>
<span class="comment">;;          (<span class="string">"dir-recursive"</span> ((default-directory t)) (<span class="string">".*"</span>) dir)</span>
<span class="comment">;;          ))</span>

<span class="comment">;;; variables</span>
<span class="comment">;;;; moccur-split-word</span>
<span class="comment">;; non-nil means to input word splited by space. You can search</span>
<span class="comment">;; <span class="string">"defun color-moccur (regexp)"</span> by <span class="string">"defun regexp"</span> or <span class="string">"regexp defun"</span>.</span>
<span class="comment">;; You don't need to input complicated regexp.</span>
<span class="comment">;; And you can search <span class="string">"defun"</span> in buffers whose name match <span class="string">"moccur"</span>.</span>

<span class="comment">;;;; dmoccur-use-list</span>
<span class="comment">;; if non-nill, M-x dmoccur is equal to C-u M-x dmoccur.</span>

<span class="comment">;;;; dmoccur-use-project</span>
<span class="comment">;; dmoccur need a name of dmoccur-list. If dmoccur-use-project is nil,</span>
<span class="comment">;; you have to type a name every time. If dmoccur-use-project is</span>
<span class="comment">;; non-nil and you searched current buffer by a name of dmoccur,</span>
<span class="comment">;; dmoccur use the name.</span>

<span class="comment">;;;; moccur-use-ee</span>
<span class="comment">;; non-nil means to display a result by ee.</span>
<span class="comment">;; ee: http<span class="builtin">://www</span>.jurta.org/emacs/ee/</span>
<span class="comment">;; if you use allout.el, it's not displayed by ee.</span>

<span class="comment">;;; sample settings</span>
<span class="comment">;; (load <span class="string">"color-moccur"</span>)</span>
<span class="comment">;; (setq *moccur-buffer-name-exclusion-list*</span>
<span class="comment">;;       '(<span class="string">".+TAGS.+"</span> <span class="string">"*Completions*"</span> <span class="string">"*Messages*"</span></span>
<span class="comment">;;         <span class="string">"newsrc.eld"</span> <span class="string">".bbdb"</span>))</span>
<span class="comment">;; (setq moccur-split-word t)</span>
<span class="comment">;; (setq dmoccur-use-list t)</span>
<span class="comment">;; (setq dmoccur-use-project t)</span>
<span class="comment">;; (setq dmoccur-list</span>
<span class="comment">;;       '(</span>
<span class="comment">;;         (<span class="string">"dir"</span> default-directory (<span class="string">".*"</span>) dir)</span>
<span class="comment">;;         (<span class="string">"soft"</span> <span class="string">"~/www/soft/"</span> (<span class="string">"\\.texi$"</span>) nil)</span>
<span class="comment">;;         (<span class="string">"config"</span> <span class="string">"~/mylisp/"</span>  (<span class="string">"\\.js"</span> <span class="string">"\\.el$"</span>) nil)</span>
<span class="comment">;;         (<span class="string">"1.99"</span> <span class="string">"d<span class="builtin">:/unix/Meadow</span>2/1.99a6/"</span> (<span class="string">".*"</span>) sub)</span>
<span class="comment">;;         ))</span>
<span class="comment">;; (global-set-key <span class="string">"\C-x\C-o"</span> 'occur-by-moccur)</span>
<span class="comment">;; (define-key Buffer-menu-mode-map <span class="string">"O"</span> 'Buffer-menu-moccur)</span>
<span class="comment">;; (define-key dired-mode-map <span class="string">"O"</span> 'dired-do-moccur)</span>
<span class="comment">;; (global-set-key <span class="string">"\C-c\C-x\C-o"</span> 'moccur)</span>
<span class="comment">;; (global-set-key <span class="string">"\M-f"</span> 'grep-buffers)</span>
<span class="comment">;; (global-set-key <span class="string">"\C-c\C-o"</span> 'search-buffers)</span>

<span class="comment">;;; Furthermore</span>
<span class="comment">;;;; Function for regexp</span>
<span class="comment">;; (moccur-set-regexp)</span>
<span class="comment">;; function to set up regexp.</span>
<span class="comment">;; if moccur-split-word is non-nil,</span>
<span class="comment">;; *moccur-regexp-list* is list of regexp.</span>
<span class="comment">;; ex. <span class="string">"defun search"</span> -&gt; moccur-regexp-list = '(<span class="string">"defun"</span> <span class="string">"search"</span>)</span>
<span class="comment">;;     <span class="string">"^[ ]+( search"</span> -&gt; moccur-regexp-list = '(<span class="string">"^[ ]+("</span> <span class="string">"search"</span>)</span>

<span class="comment">;;;; Search Function</span>
<span class="comment">;; (moccur-search-line &lt;regexp&gt;) : my original function.</span>
<span class="comment">;; basically (re-search-forward regexp nil t) (default)</span>
<span class="comment">;; If moccur-split-word is non-nil,</span>
<span class="comment">;; regexp for *moccur-search-line* is created by *moccur-set-regexp*</span>
<span class="comment">;; and *moccur-search-line* returns lines that include all of your search terms.</span>
<span class="comment">;; ex. (moccur-search-line <span class="string">"moccur defun line"</span>) matches</span>
<span class="comment">;; (<span class="keyword">defun</span> <span class="function">moccur-search-line</span></span>
<span class="comment">;; and</span>
<span class="comment">;; (<span class="keyword">defun</span> <span class="function">test</span> () (moccur-search-line regexp))</span>

<span class="comment">;; (moccur-search-buffer (<span class="type">&amp;optional</span> regexp currbuf name))</span>
<span class="comment">;; Search &lt;regexp&gt; in &lt;currbuf&gt;, and output result.</span>
<span class="comment">;; Special feature</span>
<span class="comment">;; if moccur-split-word is non-nil, first word is special.</span>
<span class="comment">;; if first word is <span class="string">";"</span>, that is, <span class="string">"; function"</span>,</span>
<span class="comment">;; moccur-search-buffer returns lines that is comment.</span>
<span class="comment">;; <span class="string">"! function"</span> -&gt; return lines that is function.</span>
<span class="comment">;; <span class="string">""</span> string<span class="string">" -&gt; return lines that is string.</span>
<span class="comment">;; "</span>/ comment<span class="string">" -&gt; return lines that is comment.</span>

<span class="comment">;; moccur-set-regexp</span>
<span class="comment">;; convert regexp for moccur.</span>

<span class="comment">;; if moccur-use-keyword is non-nil and</span>
<span class="comment">;; keyword of moccur-search-keyword-alist is in regexp,</span>
<span class="comment">;; convert keyword to &lt;regexp&gt;</span>
<span class="comment">;; ex. "</span>url<span class="string">" -&gt; "</span>[fht]*ttp<span class="builtin">://</span>[-_.!~*'()a-zA-Z0-9;/?:@<span class="type">&amp;=+</span>$,%#]+<span class="string">"</span>

<span class="comment">;;; Idea and Todo</span>

<span class="comment">;; if you have idea or function you want,</span>
<span class="comment">;; please mail to akihisa@mail.ne.jp</span>
<span class="comment">;;</span>
<span class="comment">;; Document</span>
<span class="comment">;;   --&gt; Add doc-string :)</span>
<span class="comment">;;   --&gt; defvar to defcustom</span>
<span class="comment">;;</span>
<span class="comment">;; Search</span>
<span class="comment">;;   --&gt; speed up</span>
<span class="comment">;;     --&gt; restrict ee</span>
<span class="comment">;;       --&gt; ee is slow, if count of matches is large</span>
<span class="comment">;;     --&gt; moccur stop, if result is large</span>
<span class="comment">;;   --&gt; search word</span>
<span class="comment">;;   --&gt; use history like \1 (latest word)</span>
<span class="comment">;;   --&gt; multiline search</span>
<span class="comment">;;</span>
<span class="comment">;; Buffers</span>
<span class="comment">;;   --&gt; M-x dmoccur M-x moccur : many buffers are displayed</span>
<span class="comment">;;     --&gt; I'd like to make variable to select buffers to search.</span>
<span class="comment">;;       --&gt; e.g. if current buffer is emacs-lisp-mode,</span>
<span class="comment">;;          buffers which is emacs-lisp-mode are searched in moccur.</span>
<span class="comment">;;</span>
<span class="comment">;; Usability</span>
<span class="comment">;;   --&gt; in moccur buffer, I have to type "</span>lllllll<span class="string">" or "</span>C-u 7 l<span class="string">".</span>
<span class="comment">;;       I'd like to change to displayed buffer like iswitch.</span>
<span class="comment">;;   --&gt; matched buffer list</span>
<span class="comment">;;   --&gt; add keybind (e.g. mouse...)</span>
<span class="comment">;;</span>
<span class="comment">;; moccur buffer</span>
<span class="comment">;;   --&gt; Add sort method (now alphabetic order of buffer-name)</span>
<span class="comment">;;     --&gt; probably</span>
<span class="comment">;;            buffers with same major-mode have relations...</span>
<span class="comment">;;            files in same directory have relations</span>
<span class="comment">;;            same extention?</span>
<span class="comment">;;</span>
<span class="comment">;; Bug</span>
<span class="comment">;;   --&gt; with ee, can't undo step by step</span>
<span class="comment">;;</span>
<span class="comment">;; dmoccur</span>
<span class="comment">;;   --&gt; very difficult</span>
<span class="comment">;;   --&gt; Add dired-d<span class="builtin">:/home/memo/</span>, when I searched in a directory.</span>
<span class="comment">;;   --&gt; customize buffer-menu.</span>
<span class="comment">;;       with many buffers, buffer-menu overflow.</span>

<span class="comment">;;; History<span class="builtin">:</span></span>

<span class="comment">;; 2010/05/06</span>
<span class="comment">;; Add user variable (moccur-following-mode-toggle)</span>

<span class="comment">;; 2010/04/14</span>
<span class="comment">;; Bug fix</span>
<span class="comment">;; I changed next-line to forward-line in moccur-prev and moccur-next</span>

<span class="comment">;; 2010/02/23</span>
<span class="comment">;; Bug fix.</span>
<span class="comment">;; line 2199</span>
<span class="comment">;; (cdr (reverse inputs))) -&gt; (reverse (cdr (reverse inputs))))</span>
<span class="comment">;; Thanks for patch!</span>

<span class="comment">;; 2008/7/27</span>
<span class="comment">;; Bug fix.</span>
<span class="comment">;; Add wheel mouse keybind.</span>

<span class="comment">;; 2008/7/25</span>
<span class="comment">;; Turned (back) on the key binding "</span>t<span class="string">" to "</span>moccur-toggle-view<span class="string">" command in moccur-grep-mode</span>
<span class="comment">;; Command "</span>moccur-narrow-down<span class="string">" now also works in moccur-grep-mode.</span>
<span class="comment">;; Thanks Mr. Lin. Your changes are great.</span>

<span class="comment">;; 2007/12/22</span>
<span class="comment">;; Add command "</span>g<span class="string">" (moccur-search-update) in *moccur* buffer</span>
<span class="comment">;; Abd bug fix (Thanks Mr. Lin)</span>

<span class="comment">;; 2007/12/16</span>
<span class="comment">;; Add command "</span>u<span class="string">" (moccur-search-undo) in *moccur* buffer</span>
<span class="comment">;; Update regexp (Thanks Mr. Lin)</span>

<span class="comment">;; 2007/09/05</span>
<span class="comment">;; Remove obsolete function</span>

<span class="comment">;; 2005/11/16</span>
<span class="comment">;; Add option<span class="builtin">:moccur-grep-following-mode-toggle</span></span>

<span class="comment">;; 2004/09/23</span>
<span class="comment">;; Bug fix</span>

<span class="comment">;; 2004/04/30</span>
<span class="comment">;; Add moccur-grep and moccur-grep-find</span>

<span class="comment">;; 2004/01/13</span>
<span class="comment">;; defvar -&gt; defcustom</span>

<span class="comment">;; 2004/01/05</span>
<span class="comment">;; Add moccur-search-keyword-alist</span>

<span class="comment">;; 2003/12/24</span>
<span class="comment">;; changed value of *moccur-buffer-name-exclusion-list*</span>
<span class="comment">;; New functions<span class="builtin">:isearch-moccur-all</span> ("</span>M-O<span class="string">" isearch-mode-map)</span>
<span class="comment">;; Add moccur-kill-buffer-after-goto</span>

<span class="comment">;; 2003/12/17</span>
<span class="comment">;; Bug fix: moccur-prev didn't move the cursor to another buffer.</span>
<span class="comment">;; Bug fix: if moccur-split-word is nil, special-word was used.</span>

<span class="comment">;; 2003/12/16</span>
<span class="comment">;; Update: moccur-color-view</span>
<span class="comment">;; Update: search-buffers-mode</span>
<span class="comment">;; RET: changed search-buffers-goto to search-buffers-call-moccur</span>

<span class="comment">;; 2003/12/15</span>
<span class="comment">;; Bug fix: moccur-split-string</span>

<span class="comment">;; 2003/12/12</span>
<span class="comment">;; dmoccur-list: can set file-name instead of directory</span>
<span class="comment">;; sample</span>
<span class="comment">;; (setq dmoccur-list</span>
<span class="comment">;;       '(</span>
<span class="comment">;;         ("</span>memo<span class="string">" (("</span>~/clmemo.txt<span class="string">") ;; filename</span>
<span class="comment">;;                    ("</span>~/memo/<span class="string">" t)  ;; directory</span>
<span class="comment">;;                   ) ("</span>.*<span class="string">") nil nil)</span>
<span class="comment">;;         ))</span>
<span class="comment">;; Removed internal variable, moccur-regexp</span>

<span class="comment">;; New variable: moccur-special-word-list</span>
<span class="comment">;; if moccur-split-word is t, first word is special.</span>

<span class="comment">;; Example<span class="builtin">:</span></span>
<span class="comment">;; List lines matching regexp: ; moccur</span>
<span class="comment">;; This regexp matches comment only.</span>

<span class="comment">;; List lines matching regexp: "</span> moccur</span>
<span class="comment">;; This regexp matches string only like <span class="string">"moccur"</span></span>

<span class="comment">;; List lines matching regexp: ! moccur</span>
<span class="comment">;; This regexp matches function only like defun moccur.</span>

<span class="comment">;; 2003/11/30</span>
<span class="comment">;; New functions<span class="builtin">:occur-by-moccur</span>,isearch-moccur</span>

<span class="comment">;; 2003/11/28</span>
<span class="comment">;; Bug fix: if moccur-split-word is t, when <span class="string">"["</span> is searched, error</span>

<span class="comment">;; 2003/11/26</span>
<span class="comment">;; Bug fix: set kill-buffer-after-dired-do-moccur to t and run</span>
<span class="comment">;; dired-do-moccur. After that, if you run moccur, buffers were killed.</span>
<span class="comment">;; New function<span class="builtin">:</span></span>
<span class="comment">;; In dired buffer, if a directory is marked and you run</span>
<span class="comment">;; dired-do-moccur, you can search files in the directory.</span>

<span class="comment">;; 2003/11/25</span>
<span class="comment">;; Upgrade many functions. But I can't remember changes :)</span>

<span class="comment">;; 2003/06/13</span>
<span class="comment">;; Matsushita Akihisa &lt;akihisa@mail.ne.jp&gt; improved moccur.</span>
<span class="comment">;; Add dmoccur, dired-do-moccur, Buffer-menu-moccur, and so on.</span>

<span class="comment">;; 2002 or 2003</span>
<span class="comment">;; color-moccur 1.0 was released to the net</span>

<span class="comment">;; moccur 1.0 was released to the net on August 1st, 1991</span>
<span class="comment">;; csteury@dsd.es.com (Craig Steury) provided the exclusion list</span>
<span class="comment">;; facility, which was changed to to regexps and enhanced with a</span>
<span class="comment">;; inclusion list.</span>

<span class="comment">;;; Code<span class="builtin">:</span></span>
(<span class="keyword elisp">eval-when-compile</span> (<span class="keyword">require</span> '<span class="constant">cl</span>))

(<span class="keyword">defgroup</span> <span class="type">color-moccur</span> nil
  <span class="string">"Customize color-moccur"</span>
  <span class="builtin">:group</span> 'matching)

<span class="comment">;;; variables</span>
<span class="comment">;;;; user variables</span>
(<span class="keyword">defface</span> <span class="variable">moccur-face</span>
  '((((class color)
      (background dark))
     (<span class="builtin">:background</span> <span class="string">"light grey"</span> <span class="builtin">:bold</span> t <span class="builtin">:foreground</span> <span class="string">"Black"</span>))
    (((class color)
      (background light))
     (<span class="builtin">:background</span> <span class="string">"light cyan"</span> <span class="builtin">:bold</span> t))
    (t
     ()))
  <span class="string">"*Face used by moccur to show the text that matches."</span>
  <span class="builtin">:group</span> 'color-moccur
  )

(<span class="keyword">defface</span> <span class="variable">moccur-current-line-face</span>
  '((((class color)
      (background dark))
     (<span class="builtin">:underline</span> t))
    (((class color)
      (background light))
     (<span class="builtin">:underline</span> t))
    (t
     ()))
  <span class="string">"*Face used by moccur."</span>
  <span class="builtin">:group</span> 'color-moccur
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-kill-moccur-buffer</span> nil
  <span class="string">"*Non-nil means to kill *Moccur* buffer automatically when you exit *Moccur* buffer."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-use-migemo</span> nil
  <span class="string">"*Non-nil means to use migemo (for Japanese). migemo.el is required."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-split-word</span> nil
  <span class="string">"*Non-nil means means to input word splited by space.
You can search \"defun color-moccur (regexp)\" by \"defun regexp\" or
\"regexp defun\".  You don't need to input complicated regexp.  But
you can not input regexp including space.."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">color-moccur-default-ime-status</span> t
  <span class="string">"*Non-nil means to inherit ime status."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">*moccur-buffer-name-exclusion-list*</span>
  '(<span class="string">"TAGS"</span> <span class="string">"*Completions*"</span> <span class="string">"*Messages*"</span> <span class="string">"^[ ].+"</span>)
  <span class="string">"Contains a list of regexps which don't search by moccur.
Matching buffers are *not* searched for occurrences.  Per default, the
TAGS file is excluded."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> '(repeat regexp)
  )

(<span class="keyword">defcustom</span> <span class="variable">*moccur-buffer-name-inclusion-list*</span> '(<span class="string">"[<span class="negation">^</span> ].*"</span>)
  <span class="string">"Contains a list of regexps.  *Only* matching buffers are searched.
Per default, this var contains only a \".*\" catchall-regexp."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> '(repeat regexp)
  )

(<span class="keyword">defcustom</span> <span class="variable">dmoccur-mask</span> '(<span class="string">".*"</span>)
  <span class="string">"Mask for dmoccur."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> '(repeat regexp)
  )

(<span class="keyword">defcustom</span> <span class="variable">dmoccur-maximum-size</span> nil
  <span class="string">"*Maximum size (kB) of a buffer for dmoccur and moccur-grep(-find)."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> '(choice
          number
          (const <span class="builtin">:tag</span> <span class="string">"infinite"</span> nil))
  )

(<span class="keyword">defcustom</span> <span class="variable">dmoccur-exclusion-mask</span>
  '( <span class="comment">;; binary</span>
    <span class="string">"\\.elc$"</span> <span class="string">"\\.exe$"</span> <span class="string">"\\.dll$"</span> <span class="string">"\\.lib$"</span> <span class="string">"\\.lzh$"</span>
    <span class="string">"\\.zip$"</span> <span class="string">"\\.deb$"</span> <span class="string">"\\.gz$"</span> <span class="string">"\\.pdf$"</span> <span class="string">"\\.tar$"</span>
    <span class="string">"\\.gz$"</span> <span class="string">"\\.7z$"</span> <span class="string">"\\.o$"</span> <span class="string">"\\.a$"</span> <span class="string">"\\.mod$"</span>
    <span class="string">"\\.nc$"</span> <span class="string">"\\.obj$"</span> <span class="string">"\\.ai$"</span> <span class="string">"\\.fla$"</span> <span class="string">"\\.swf$"</span>
    <span class="string">"\\.dvi$"</span> <span class="string">"\\.pdf$"</span> <span class="string">"\\.bz2$"</span> <span class="string">"\\.tgz$"</span> <span class="string">"\\.cab$"</span>
    <span class="string">"\\.sea$"</span> <span class="string">"\\.bin$"</span> <span class="string">"\\.fon$"</span> <span class="string">"\\.fnt$"</span> <span class="string">"\\.scr$"</span>
    <span class="string">"\\.tmp$"</span> <span class="string">"\\.wrl$"</span> <span class="string">"\\.Z$"</span>
    <span class="comment">;; sound &amp; movie</span>
    <span class="string">"\\.aif$"</span> <span class="string">"\\.aiff$"</span>  <span class="string">"\\.mp3$"</span>  <span class="string">"\\.wma$"</span> <span class="string">"\\.mpg$"</span>
    <span class="string">"\\.mpeg$"</span> <span class="string">"\\.aac$"</span> <span class="string">"\\.mid$"</span>  <span class="string">"\\.au$"</span>  <span class="string">"\\.avi$"</span>  <span class="string">"\\.dcr$"</span>
    <span class="string">"\\.dir$"</span>  <span class="string">"\\.dxr$"</span> <span class="string">"\\.midi$"</span>  <span class="string">"\\.mov$"</span>  <span class="string">"\\.ra$"</span>  <span class="string">"\\.ram$"</span>
    <span class="string">"\\.vdo$"</span> <span class="string">"\\.wav$"</span>
    <span class="comment">;; Microsoft</span>
    <span class="string">"\\.doc$"</span> <span class="string">"\\.xls$"</span> <span class="string">"\\.ppt$"</span> <span class="string">"\\.mdb$"</span> <span class="string">"\\.adp$"</span>
    <span class="string">"\\.wri$"</span>
    <span class="comment">;; image</span>
    <span class="string">"\\.jpg$"</span> <span class="string">"\\.gif$"</span> <span class="string">"\\.tiff$"</span> <span class="string">"\\.tif$"</span> <span class="string">"\\.bmp$"</span>
    <span class="string">"\\.png$"</span> <span class="string">"\\.pbm$"</span> <span class="string">"\\.jpeg$"</span> <span class="string">"\\.xpm$"</span> <span class="string">"\\.pbm$"</span>
    <span class="string">"\\.ico$"</span> <span class="string">"\\.eps$"</span> <span class="string">"\\.psd$"</span>
    <span class="comment">;;etc</span>
    <span class="string">"/TAGS$"</span>
    <span class="comment">;; backup file</span>
    <span class="string">"\\~$"</span>
    <span class="comment">;; version control</span>
    <span class="string">"\\.svn/.+"</span> <span class="string">"CVS/.+"</span> <span class="string">"\\.git/.+"</span>
    )
  <span class="string">"*List of file extensions which are excepted to search by dmoccur and moccur-grep(-find)."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> '(repeat regexp)
  )

(<span class="keyword">defcustom</span> <span class="variable">dmoccur-use-list</span> nil
  <span class="string">"Non-nil means to use your favorite directory list."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">dmoccur-use-project</span> nil
  <span class="string">"Non-nil means to use your favorite directory list."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-use-ee</span> nil
  <span class="string">"Non-nil means to use ee. However, this feature doesn't work now"</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">kill-buffer-after-dired-do-moccur</span> nil
  <span class="string">"Non-nil means to kill buffer after dired do moccur."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">dmoccur-list</span>
  '(
    <span class="comment">;; name directory mask option</span>
    <span class="comment">;; option = nil , dir , sub</span>
    (<span class="string">"dir"</span> default-directory (<span class="string">".*"</span>) dir)
    (<span class="string">"lisp"</span> <span class="string">"~/mylisp/"</span> (<span class="string">"\\.el"</span> <span class="string">"\\.*texi"</span>) nil))
  <span class="string">"*List of directory which are searched by dmoccur."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> '(repeat
          (list (string <span class="builtin">:tag</span> <span class="string">"Name"</span>)
                (choice
                 (directory <span class="builtin">:tag</span> <span class="string">"Directory"</span>)
                 (file <span class="builtin">:tag</span> <span class="string">"Filename"</span>)
                 (symbol <span class="builtin">:tag</span> <span class="string">"Variable"</span>)
                 (repeat <span class="builtin">:tag</span> <span class="string">"Advanced setting"</span>
                         (list
                          (choice
                           (directory <span class="builtin">:tag</span> <span class="string">"Directory"</span>)
                           (symbol <span class="builtin">:tag</span> <span class="string">"Variable"</span>))
                          (boolean <span class="builtin">:tag</span> <span class="string">"Recursively"</span> nil)
                          (repeat <span class="builtin">:tag</span> <span class="string">"File Mask"</span>
                                  (regexp <span class="builtin">:tag</span> <span class="string">"File Mask not to search"</span>)))))
                (repeat <span class="builtin">:tag</span> <span class="string">"File Mask"</span> <span class="builtin">:default</span> nil
                        (regexp <span class="builtin">:tag</span> <span class="string">"File Mask"</span> <span class="string">".*"</span>))
                (choice <span class="builtin">:tag</span> <span class="string">"Option"</span> <span class="builtin">:default</span> nil
                        (const <span class="builtin">:tag</span> <span class="string">"Default"</span> nil)
                        (const <span class="builtin">:tag</span> <span class="string">"Directory"</span> dir)
                        (const <span class="builtin">:tag</span> <span class="string">"Subdirectory"</span> sub))
                (choice <span class="builtin">:tag</span> <span class="string">"Control Migemo and Split"</span> <span class="builtin">:default</span> nil
                        (const <span class="builtin">:tag</span> <span class="string">"Default"</span> nil)
                        (list (boolean <span class="builtin">:tag</span> <span class="string">"Use Migemo"</span> nil)
                              (boolean <span class="builtin">:tag</span> <span class="string">"Split Regexp"</span> nil)))
                (choice <span class="builtin">:tag</span> <span class="string">"Default regexp"</span> <span class="builtin">:default</span> nil
                        (const <span class="builtin">:tag</span> <span class="string">"Empty"</span> nil)
                        (string <span class="builtin">:tag</span> <span class="string">"Regexp"</span> <span class="string">""</span>)
                        (symbol <span class="builtin">:tag</span> <span class="string">"Function to make regexp"</span>)))))

(<span class="keyword">defcustom</span> <span class="variable">moccur-maximum-displayed-with-color</span> 500
  <span class="string">"Max number that is displayed with color."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'number
  )

(<span class="keyword">defcustom</span> <span class="variable">dmoccur-recursive-search</span> nil
  <span class="string">"Non-nil means to search files recursively."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-buffer-sort-method</span> 'moccur-filepath-string&lt;
  <span class="string">"Function to sort buffers."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'symbol
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-special-word-list</span>
  '(
    (<span class="string">"<span class="comment">;"</span></span>
     moccur-face-initialization
     moccur-comment-check)
    (<span class="string">"/"</span>
     moccur-face-initialization
     moccur-comment-check)
    (<span class="string">"\""</span>
     moccur-face-initialization
     moccur-string-check)
    (<span class="string">"!"</span>
     moccur-face-initialization
     moccur-function-check)
    (t <span class="comment">;; default</span>
     moccur-default-initial-function
     moccur-default-check-function
     )
    )
  <span class="string">"Special-word function-to-initialize function-to-check."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> '(repeat
          (list (choice (string <span class="builtin">:tag</span> <span class="string">"Keyword"</span>)
                        (const <span class="builtin">:tag</span> <span class="string">"Default"</span> t))
                (symbol <span class="builtin">:tag</span> <span class="string">"Function to initialize"</span>)
                (symbol <span class="builtin">:tag</span> <span class="string">"Function to check"</span>)
                )))

(<span class="keyword">defcustom</span> <span class="variable">moccur-kill-buffer-after-goto</span> nil
  <span class="string">"Non-nil means to kill *moccur* buffer after goto-occurrence."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-search-keyword-alist</span>
  '((<span class="string">"url"</span>  . <span class="string">"[fht]*ttp<span class="builtin">://</span>[-_.!~*'()a-zA-Z0-9<span class="comment">;/?:@<span class="type">&amp;=+</span>$,%#]+"</span>)</span>
    (<span class="string">"mail"</span> . <span class="string">"[<span class="negation">^</span>][&lt;&gt;@ \n]+@[-_!~*'()a-zA-Z0-9?@<span class="type">&amp;=+</span>$,%#]+\\.[-_.!~*'()a-zA-Z0-9?@<span class="type">&amp;=+</span>$,%#]+"</span>))
  <span class="string">"*Alist of KEYWORD and REGEXP."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> '(repeat
          (cons (string <span class="builtin">:tag</span> <span class="string">"Keyword"</span>)
                (regexp <span class="builtin">:tag</span> <span class="string">"Regexp"</span>))))

(<span class="keyword">defcustom</span> <span class="variable">moccur-use-keyword</span> nil
  <span class="string">"Non-nil means to use moccur-search-keyword-alist."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-use-xdoc</span>2txt
  (<span class="keyword elisp">if</span>
      (and
       (locate-library <span class="string">"xdoc2txt.exe"</span> nil exec-path)
       (<span class="keyword elisp">if</span> (file-name-extension shell-file-name)
           (locate-library shell-file-name nil exec-path)
         (locate-library (concat shell-file-name <span class="string">".exe"</span>) nil exec-path)))
      t
    nil)
  <span class="string">"Non-nil means to use xdoc2txt.
xdoc2txt is Windows software to convert Word/Excel/PDF etc to Text file.
http<span class="builtin">://www</span>31.ocn.ne.jp/~h_ishida/xdoc2txt.html (Japanese site)"</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-grep-xdoc</span>2txt-maximum-size 1000
  <span class="string">"*Maximum size (kB) of a buffer for xdoc2txt."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'number
  )

(<span class="keyword">defcustom</span> <span class="variable">moccur-grep-xdoc</span>2txt-exts '(
                                       <span class="string">"\\.rtf"</span> <span class="string">"\\.doc"</span> <span class="string">"\\.xls"</span> <span class="string">"\\.ppt"</span>
                                       <span class="string">"\\.jaw"</span> <span class="string">"\\.jtw"</span> <span class="string">"\\.jbw"</span> <span class="string">"\\.juw"</span>
                                       <span class="string">"\\.jfw"</span> <span class="string">"\\.jvw"</span> <span class="string">"\\.jtd"</span> <span class="string">"\\.jtt"</span>
                                       <span class="string">"\\.oas"</span> <span class="string">"\\.oa2"</span> <span class="string">"\\.oa3"</span> <span class="string">"\\.bun"</span>
                                       <span class="string">"\\.wj2"</span> <span class="string">"\\.wj3"</span> <span class="string">"\\.wk3"</span> <span class="string">"\\.wk4"</span>
                                       <span class="string">"\\.123"</span> <span class="string">"\\.wri"</span> <span class="string">"\\.pdf"</span> <span class="string">"\\.mht"</span>)
  <span class="string">"*List of file extensions which are handled by xdoc2txt."</span>
  <span class="builtin">:type</span> '(repeat string)
  <span class="builtin">:group</span> 'Meadow-Memo)

(<span class="keyword">defcustom</span> <span class="variable">moccur-following-mode-toggle</span> t
  <span class="string">"When t, cursor motion in the moccur buffer causes
automatic display of the corresponding buffer location."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean)

(<span class="keyword">defcustom</span> <span class="variable">moccur-grep-following-mode-toggle</span> t
  <span class="string">"When t, cursor motion in the moccur-grep buffer causes
automatic display of the corresponding source code location."</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean)

(<span class="keyword">defcustom</span> <span class="variable">moccur-grep-default-word-near-point</span> nil
  <span class="string">"When t, get a word near the point as default regexp string"</span>
  <span class="builtin">:group</span> 'color-moccur
  <span class="builtin">:type</span> 'boolean)

(<span class="keyword">defvar</span> <span class="variable">moccur-grep-default-mask</span> nil
  <span class="string">"File-mask string used for default in moccur-grep and moccur-grep-find"</span>)
(make-variable-buffer-local 'moccur-grep-default-mask)

<span class="comment">;;; Internal variables</span>
<span class="comment">;;;; moccur</span>
(<span class="keyword">defvar</span> <span class="variable">moccur-buffer-heading-regexp</span> <span class="string">"^[-+ ]*Buffer: \\([<span class="negation">^</span>\r\n]+\\) File: \\([<span class="negation">^</span>\r\n]+\\)$"</span>
  <span class="string">"Regexp for matching buffer heading line in moccur-mode buffer."</span>)
(<span class="keyword">defvar</span> <span class="variable">moccur-grep-buffer-heading-regexp</span> <span class="string">"^[-+ ]*Buffer: File (grep): \\([<span class="negation">^</span>\r\n]+\\)$"</span>
  <span class="string">"Regexp for matching buffer heading line in moccur-grep-mode buffer."</span>)
(<span class="keyword">defvar</span> <span class="variable">moccur-line-number-regexp</span> <span class="string">"^[ ]*\\([0-9]+\\) "</span>
  <span class="string">"Regexp for matching line numbers in moccur buffer."</span>)
(<span class="keyword">defvar</span> <span class="variable">regexp</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-list</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-overlays</span> nil)
(make-variable-buffer-local 'moccur-overlays)
(<span class="keyword">defvar</span> <span class="variable">moccur-current-line-overlays</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-regexp-color</span> <span class="string">""</span>)
(<span class="keyword">defvar</span> <span class="variable">moccur-regexp-list</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-file-name-regexp</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-regexp-input</span> <span class="string">""</span>)
(<span class="keyword">defvar</span> <span class="variable">moccur-buffer-name</span> <span class="string">""</span>)
(<span class="keyword">defvar</span> <span class="variable">moccur-buffer-match-count</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-before-buffer-name</span> <span class="string">""</span>)
(<span class="keyword">defvar</span> <span class="variable">moccur-line</span> nil)
(<span class="keyword">defvar</span> <span class="variable">buffer-menu-moccur</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-view-other-window</span> t)
(make-variable-buffer-local 'moccur-view-other-window)
(<span class="keyword">defvar</span> <span class="variable">moccur-view-other-window-nobuf</span> t)
(make-variable-buffer-local 'moccur-view-other-window-nobuf)
(<span class="keyword">defvar</span> <span class="variable">moccur-current-buffer</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-buffer-position</span> nil)
(make-variable-buffer-local 'moccur-buffer-position)
(<span class="keyword">defvar</span> <span class="variable">moccur-buffers</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-match-buffers</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-buffers-before-moccur</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-matches</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-mocur-buffer</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-last-command</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-windows-conf</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-special-word</span> nil)
(<span class="keyword">defvar</span> <span class="variable">moccur-fontlock-buffer</span> nil)
(make-variable-buffer-local 'moccur-fontlock-buffer)
<span class="comment">;;;; dmoccur</span>
(<span class="keyword">defvar</span> <span class="variable">dmoccur-mask-internal</span> nil)
(<span class="keyword">defvar</span> <span class="variable">dmoccur-history</span> nil)
(<span class="keyword">defvar</span> <span class="variable">dmoccur-list-history</span> nil)
(<span class="keyword">defvar</span> <span class="variable">dmoccur-buffer-project</span> nil)
(make-variable-buffer-local 'dmoccur-buffer-project)
(<span class="keyword">defvar</span> <span class="variable">dmoccur-project-name</span> nil)
(<span class="keyword">defvar</span> <span class="variable">dmoccur-project-list</span> nil)
(<span class="keyword">defvar</span> <span class="variable">dmoccur-recursive-ignore-dir</span> nil)
<span class="comment">;;;; moccur-grep</span>
(<span class="keyword">defvar</span> <span class="variable">moccur-grep-buffer-list</span> nil)
(make-variable-buffer-local 'moccur-grep-buffer-list)
(<span class="keyword">defvar</span> <span class="variable">moccur-xdoc</span>2txt-buffers nil)
(make-variable-buffer-local 'moccur-xdoc2txt-buffers)
(<span class="keyword">defvar</span> <span class="variable">moccur-run-meadow-onwin</span>
  (and
   <span class="comment">;; run win32</span>
   (and
    (null
     (or (equal system-type 'gnu/linux)
         (equal system-type 'usg-unix-v)))
    (or (equal system-type 'windows-nt)
        (equal system-type 'ms-dos)))
   <span class="comment">;; meadow</span>
   (<span class="keyword">featurep</span> '<span class="constant">meadow</span>)))
(<span class="keyword">defvar</span> <span class="variable">moccur-grep-search-file-pos</span> nil)

<span class="comment">;;; For All Emacs</span>
(<span class="keyword">defmacro</span> <span class="function">string</span>&gt; (a b) (list 'not (list 'or (list 'string= a b)
                                         (list 'string&lt; a b))))
(autoload 'migemo-get-pattern <span class="string">"migemo"</span> <span class="string">"migemo-get-pattern"</span> nil)

<span class="comment">;;; For xemacs</span>
(<span class="keyword cl">unless</span> (fboundp 'match-string-no-properties)
  (<span class="keyword">defalias</span> '<span class="function">match-string-no-properties</span> 'match-string))
(<span class="keyword cl">when</span> (and (boundp 'running-xemacs) running-xemacs)
  (<span class="keyword">require</span> '<span class="constant">overlay</span>)
  (<span class="keyword elisp">if</span> (not (functionp 'line-beginning-position))
      (fset 'line-beginning-position 'point-at-bol))
  (<span class="keyword elisp">if</span> (not (functionp 'line-end-position))
      (fset 'line-end-position 'point-at-eol)))

<span class="comment">;;; moccur and other packages</span>
<span class="comment">;;;; moccur + isearch</span>
(<span class="keyword">defun</span> <span class="function">isearch-moccur</span> ()
  <span class="string">"Invoke `<span class="constant important">moccur</span>' from isearch within `<span class="constant important">current-buffer</span>'."</span>
  (interactive)
  (<span class="keyword elisp">let</span> ((<span class="keyword cl">case</span>-fold-search isearch-case-fold-search) (isearch-buffer (current-buffer)))
    (isearch-exit)
    (moccur-setup)
    (moccur-search
     (<span class="keyword elisp">if</span> isearch-regexp
         isearch-string
       (regexp-quote isearch-string))
     t
     (list isearch-buffer))))

(<span class="keyword">defun</span> <span class="function">isearch-moccur-all</span> ()
  <span class="string">"Invoke `<span class="constant important">moccur</span>' from isearch in all buffers."</span>
  (interactive)
  (<span class="keyword elisp">let</span> ((<span class="keyword cl">case</span>-fold-search isearch-case-fold-search)
        (buffers (moccur-filter-buffers (buffer-list))))
    <span class="comment">;; sort</span>
    (setq buffers (sort buffers moccur-buffer-sort-method))
    (isearch-exit)
    (moccur-setup)
    (moccur-search
     (<span class="keyword elisp">if</span> isearch-regexp
         isearch-string
       (regexp-quote isearch-string))
     t
     buffers)))

(define-key isearch-mode-map (kbd <span class="string">"M-o"</span>) 'isearch-moccur)
(define-key isearch-mode-map (kbd <span class="string">"M-O"</span>) 'isearch-moccur-all)

<span class="comment">;;;; occur</span>
(<span class="keyword">defun</span> <span class="function">occur-by-moccur</span> (regexp arg)
  <span class="string">"Use this instead of occur.
Argument REGEXP regexp.
Argument ARG whether buffers which is not related to files are searched."</span>
  (interactive (list (moccur-regexp-read-from-minibuf)
                     current-prefix-arg))
  (moccur-setup)

  (setq moccur-regexp-input regexp)

  (<span class="keyword elisp">let</span> ((buffers (list (current-buffer))))
    (moccur-search regexp t buffers)))

<span class="comment">;;; moccur<span class="builtin">:function</span></span>
<span class="comment">;;;; utility</span>
(<span class="keyword">defun</span> <span class="function">moccur-filepath-string</span>&lt; (buf1 buf2)
  <span class="string">"String&lt; by function `<span class="constant important">buffer-file-name</span>'.
Argument BUF1 BUFFER.
Argument BUF2 BUFFER."</span>
  (<span class="keyword elisp">if</span> (and (buffer-file-name buf1)
           (buffer-file-name buf2))
      (string&lt; (buffer-file-name buf1) (buffer-file-name buf2))
    (<span class="keyword elisp">if</span> (buffer-file-name buf1)
        buf1
      (<span class="keyword elisp">if</span> (buffer-file-name buf2)
          buf2
        (string&lt; (buffer-name buf1) (buffer-name buf2))))))

(<span class="keyword">defun</span> <span class="function">moccur-buffer-string</span>&lt; (buf1 buf2)
  <span class="string">"String&lt; by `<span class="constant important">buffer-name</span>'.
Argument BUF1 BUFFER.
Argument BUF2 BUFFER."</span>
  (string&lt; (buffer-name buf1) (buffer-name buf2)))

(<span class="keyword">defun</span> <span class="function">moccur-buffer-string</span>&gt; (buf1 buf2)
  <span class="string">"String&gt; by `<span class="constant important">buffer-name</span>'.
Argument BUF1 BUFFER.
Argument BUF2 BUFFER."</span>
  (string&gt; (buffer-name buf1) (buffer-name buf2)))

(<span class="keyword">defun</span> <span class="function">moccur-buffer-in-list-p</span> (buffer-name buffer-name-regexps)
  <span class="string">"Return t, if BUFFER-NAME match BUFFER-NAME-REGEXPS (list)."</span>
  (<span class="keyword elisp">cond</span> ((null buffer-name-regexps) nil)
        ((eq (string-match (car buffer-name-regexps) buffer-name)
             0) t)
        (t (moccur-buffer-in-list-p
            buffer-name (cdr buffer-name-regexps)))))

(<span class="keyword">defun</span> <span class="function">moccur-filter-buffers</span> (buffer-list)
  <span class="string">"Return BUFFER-LIST which is filtered by some variables."</span>
  (<span class="keyword elisp">let</span> ((moccur-buffers nil))
    (<span class="keyword elisp">while</span> buffer-list
      (<span class="keyword elisp">if</span> (and (moccur-buffer-in-list-p
                (buffer-name (car buffer-list))
                *moccur-buffer-name-inclusion-list*)
               (not (moccur-buffer-in-list-p
                     (buffer-name (car buffer-list))
                     *moccur-buffer-name-exclusion-list*)))
          (setq moccur-buffers
                (cons (car buffer-list)
                      moccur-buffers)))
      (setq buffer-list (cdr buffer-list)))
    moccur-buffers))

(<span class="keyword">defun</span> <span class="function">moccur-kill-buffer-func</span> ()
  (<span class="keyword cl">when</span> (get-buffer <span class="string">"*Moccur*"</span>) <span class="comment">;; there ought to be just one of these</span>
    (<span class="keyword elisp">let</span> ((cur-buffer (current-buffer)))
      (<span class="keyword elisp">save-excursion</span>
        (set-buffer <span class="string">"*Moccur*"</span>)
        <span class="comment">;; remove current buffer from moccur-grep-buffer-list so it won't get killed in</span>
        <span class="comment">;; moccur-grep-sync-kill-buffers</span>
        (setq moccur-grep-buffer-list (remq cur-buffer moccur-grep-buffer-list))))
    (kill-buffer <span class="string">"*Moccur*"</span>))
  (<span class="keyword elisp">if</span> (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>)
      (kill-buffer <span class="string">"*ee-outline*/*Moccur*"</span>)))

(<span class="keyword">defun</span> <span class="function">moccur-kill-buffer</span> (arg)
  <span class="string">"Kill buffers related moccur."</span>
  (<span class="keyword elisp">if</span> arg
      (moccur-kill-buffer-func)
    (<span class="keyword elisp">if</span> moccur-kill-moccur-buffer
        (moccur-kill-buffer-func)
      (bury-buffer))))

(<span class="keyword">defun</span> <span class="function">moccur-bury-buffer</span> ()
  <span class="string">"Kill buffers related moccur."</span>
  (<span class="keyword elisp">if</span> (get-buffer <span class="string">"*Moccur*"</span>) <span class="comment">;; there ought to be just one of these</span>
      (bury-buffer (get-buffer <span class="string">"*Moccur*"</span>)))
  (<span class="keyword elisp">if</span> (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>)
      (bury-buffer (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>))))

(autoload 'ee-outline <span class="string">"ee-autoloads"</span> nil t)
(<span class="keyword">defun</span> <span class="function">moccur-setup</span> ()
  <span class="string">"Initialization of moccur."</span>
  <span class="comment">;;(setq moccur-last-command 'moccur)</span>
  (<span class="keyword elisp">if</span> moccur-use-migemo
      (<span class="keyword">require</span> '<span class="constant">migemo</span>))
  (<span class="keyword elisp">if</span> moccur-use-ee
      (<span class="keyword">require</span> '<span class="constant">ee-autoloads</span>))
  (<span class="keyword elisp">if</span> (string= <span class="string">"*Moccur*"</span>
               (buffer-name (current-buffer)))
      (moccur-quit))
  (moccur-kill-buffer t)
  (setq moccur-current-buffer (current-buffer))
  (setq moccur-windows-conf (current-window-configuration)))

(<span class="keyword">defun</span> <span class="function">moccur-insert-heading</span>(moccur-regexp-input)
  <span class="string">"Insert the 'Lines matching' heading in *Moccur* buffer, with the user input regexp
 displayed in font-lock-variable-name-face face."</span>
  (<span class="keyword elisp">let</span> (pt)
    (setq pt (point))
    (insert <span class="string">"Lines matching"</span>)
    (<span class="keyword cl">when</span> moccur-split-word
      (insert <span class="string">" (split words)"</span>))
    (insert <span class="string">": "</span>)
    (put-text-property pt (point) 'face 'font-lock-keyword-face)
    (setq pt (point))
    (insert moccur-regexp-input <span class="string">"\n"</span>)
    (put-text-property pt (point) 'face 'font-lock-variable-name-face)))

(<span class="keyword">defun</span> <span class="function">moccur-file-size</span>&lt; (filename maxsize)
  (<span class="keyword elisp">if</span>
      (or
       (not maxsize)
       (&gt; (* 1000 maxsize)
          (nth 7 (file-attributes filename))))
      t
    nil))

<span class="comment">;;;; color and overlay</span>
(<span class="keyword">defun</span> <span class="function">moccur-remove-overlays-on-all-buffers</span> (<span class="type">&amp;optional</span> beg end length)
  <span class="string">"Remove all overlays in all buffers.
Optional argument BEG
 the positions of the beginning of the range of changed text
Optional argument END
 the positions of the end of the range of changed text
Optional argument LENGTH
 the length in bytes of the pre-change text replaced by that range."</span>
  (interactive <span class="string">"p"</span>)
  (<span class="keyword elisp">if</span> moccur-current-line-overlays
      (<span class="keyword elisp">progn</span>
        (delete-overlay moccur-current-line-overlays)
        (setq moccur-current-line-overlays nil)))
  (<span class="keyword elisp">save-excursion</span>
    (<span class="keyword elisp">let</span> (ov buf (buflist (buffer-list)))
      (<span class="keyword elisp">while</span> buflist
        (setq buf (car buflist))
        (setq buflist (cdr buflist))
        (<span class="keyword cl">when</span> (and buf
                   (buffer-live-p buf))
          (set-buffer buf)
          (<span class="keyword cl">when</span> (not (memq major-mode '(moccur-mode moccur-grep-mode)))
            (<span class="keyword elisp">while</span> moccur-overlays
              (delete-overlay (car moccur-overlays))
              (setq moccur-overlays (cdr moccur-overlays))))
          (remove-hook 'after-change-functions
                       'moccur-remove-overlays-on-all-buffers)
          (<span class="keyword cl">when</span> moccur-buffer-position
            (goto-char moccur-buffer-position)
            (setq moccur-buffer-position nil)))))))

(<span class="keyword">defun</span> <span class="function">moccur-buffer-hide-region</span> (start end)
  (<span class="keyword elisp">let</span> ((o (make-overlay start end)))
    (overlay-put o 'invisible 'moccur)
    (overlay-put o 'isearch-open-invisible
                 'outline-isearch-open-invisible)))

(<span class="keyword">defun</span> <span class="function">moccur-buffer-color</span> ()
  <span class="string">"Put overlays in *moccur* buffer."</span>
  (<span class="keyword elisp">let</span> ((ov) (count 0))
    (<span class="keyword elisp">save-excursion</span>
      (goto-char (point-min))
      (<span class="keyword elisp">while</span> (and (re-search-forward moccur-line-number-regexp nil t)
                  (or (not moccur-maximum-displayed-with-color)
                      (&lt; count moccur-maximum-displayed-with-color)))
        (<span class="keyword elisp">progn</span>
          (<span class="keyword elisp">save-restriction</span>
            (narrow-to-region (point) (line-end-position))
            (<span class="keyword elisp">while</span> (re-search-forward moccur-regexp-color nil t)
              (setq count (+ count 1))
              (setq ov (make-overlay (match-beginning 0)
                                     (match-end 0)))
              (overlay-put ov 'face 'moccur-face)
              (overlay-put ov 'priority 0)
              (setq moccur-overlays (cons ov moccur-overlays))))
          (<span class="keyword cl">when</span> (&gt; (+ 6 (<span class="keyword elisp">save-excursion</span> (end-of-line) (current-column)))
                   (<span class="keyword elisp">if</span> (and (boundp 'running-xemacs) running-xemacs)
                       (frame-width)
                     (frame-width)))
            (<span class="keyword elisp">save-excursion</span>
              (beginning-of-line)
              (re-search-forward moccur-line-number-regexp (line-end-position) t)
              (<span class="keyword elisp">save-restriction</span>
                (narrow-to-region (point) (line-end-position))
                (<span class="keyword elisp">let</span> ((end-pt (point)) (st (point)) (match-end-pt nil))
                  (<span class="keyword elisp">while</span> (re-search-forward moccur-regexp-color (line-end-position) t)
                    (setq st (match-beginning 0))
                    (setq match-end-pt (match-end 0))
                    (<span class="keyword elisp">cond</span>
                     ((and
                       (&gt; (length (buffer-substring-no-properties
                                   end-pt st))
                          10)
                       (&lt; end-pt (- st 5)))
                      (moccur-buffer-hide-region end-pt (- st 5))
                      (setq end-pt (+ 5 match-end-pt)))
                     (t
                      (setq end-pt (+ 5 match-end-pt))
                      (goto-char end-pt)
                      )))
                  (end-of-line)
                  (<span class="keyword elisp">if</span> (and
                       (&gt; (line-end-position) end-pt)
                       (&gt; (length (buffer-substring-no-properties
                                   end-pt (line-end-position)))
                          10))
                      (moccur-buffer-hide-region end-pt (- (line-end-position) 5)))))))
          )))))

(<span class="keyword">defun</span> <span class="function">moccur-color-view</span> ()
  <span class="string">"Put overlays to matched texts."</span>
  (<span class="keyword elisp">let</span> ((ov) (count 0))
    (<span class="keyword elisp">if</span> (and moccur-buffer-name
             (get-buffer moccur-buffer-name))
        (<span class="keyword elisp">progn</span>
          (set-buffer (get-buffer moccur-buffer-name))
          (<span class="keyword cl">when</span> moccur-current-line-overlays
            (delete-overlay moccur-current-line-overlays)
            (setq moccur-current-line-overlays nil))

          (<span class="keyword elisp">save-excursion</span>
            (goto-char (point-min))
            (moccur-special-word-call-initialize-function)
            (<span class="keyword elisp">while</span> (and
                    (moccur-search-line (car moccur-regexp-list))
                    (or (not moccur-maximum-displayed-with-color)
                        (&lt; count moccur-maximum-displayed-with-color)))
              (<span class="keyword cl">when</span> (moccur-special-word-call-check-function)
                (beginning-of-line)
                (<span class="keyword elisp">while</span> (and
                        (re-search-forward
                         moccur-regexp-color (line-end-position) t)
                        (or (not moccur-maximum-displayed-with-color)
                            (&lt; count moccur-maximum-displayed-with-color)))
                  (<span class="keyword elisp">progn</span>
                    (setq count (+ count 1))
                    (setq ov (make-overlay (match-beginning 0)
                                           (match-end 0)))
                    (overlay-put ov 'face 'moccur-face)
                    (overlay-put ov 'priority 0)
                    (setq moccur-overlays (cons ov moccur-overlays)))))))
          (set-buffer moccur-mocur-buffer)))))

(<span class="keyword">defun</span> <span class="function">moccur-color-current-line</span> ()
  <span class="string">"Underline where the cursor is."</span>
  (<span class="keyword elisp">if</span> (not moccur-current-line-overlays)
      (setq moccur-current-line-overlays
            (make-overlay
             (line-beginning-position) (1+ (line-end-position))))
    (move-overlay moccur-current-line-overlays
                  (line-beginning-position) (1+ (line-end-position))))
  (overlay-put moccur-current-line-overlays
               'face 'moccur-current-line-face))

<span class="comment">;;;; display other window</span>
(<span class="keyword">defun</span> <span class="function">moccur-get-info</span> ()
  <span class="string">"Gets buffer name and line."</span>
  (setq moccur-view-other-window-nobuf t)
  (setq moccur-buffer-name nil)
  (<span class="keyword elisp">let</span> ((end-pt) (start-pt) (file nil) (buffer nil) (str nil) (buf nil)
        (buflst (buffer-list)))
    <span class="comment">;;for moccur-grep</span>
    (<span class="keyword cl">when</span> moccur-grep-following-mode-toggle
      (<span class="keyword elisp">save-window-excursion</span>
        (<span class="keyword elisp">save-excursion</span>
          (moccur-grep-goto)
          (setq buf (current-buffer))))
      (<span class="keyword elisp">if</span> (or
           (memq buf buflst)
           (memq buf moccur-grep-buffer-list))
          ()
        (setq moccur-grep-buffer-list
              (cons buf moccur-grep-buffer-list))))
    <span class="comment">;;for moccur-grep end</span>
    (<span class="keyword elisp">save-excursion</span>
      (end-of-line)
      (<span class="keyword elisp">if</span> (re-search-backward
           <span class="string">"^[-+ ]*Buffer:[ ]*\\([<span class="negation">^</span>\r\n]*\\) File\\([<span class="negation">^</span><span class="builtin">:/</span>\r\n]*\\):[ ]*\\([<span class="negation">^</span>\r\n]+\\)$"</span> nil t)
          (<span class="keyword elisp">progn</span>
            (setq start-pt (point))
            (setq buffer
                  (match-string-no-properties 1))
            (setq str (match-string-no-properties 2))
            (setq file (match-string-no-properties 3))
            (<span class="keyword elisp">cond</span>
             ((string-match <span class="string">"grep"</span> str)
              (<span class="keyword elisp">if</span> (moccur-grep-xdoc2txt-p file)
                  (setq moccur-buffer-name (moccur-grep-binary-file-view file))
                (<span class="keyword elisp">if</span> (get-file-buffer file)
                    (setq moccur-buffer-name
                          (buffer-name
                           (get-file-buffer file))))))
             (t
              (setq moccur-buffer-name buffer))))
        (setq start-pt (point-min))))

    (<span class="keyword elisp">save-excursion</span>
      (end-of-line)
      (<span class="keyword elisp">if</span> (re-search-forward
           <span class="string">"^[-+ ]*Buffer: "</span> nil t)
          (<span class="keyword elisp">progn</span>
            (beginning-of-line)
            (setq end-pt (point)))
        (setq end-pt (point-max))))

    (<span class="keyword elisp">save-excursion</span>
      (setq moccur-buffer-match-count 0)
      (goto-char start-pt)
      (<span class="keyword elisp">while</span> (re-search-forward moccur-line-number-regexp end-pt t)
        (setq moccur-buffer-match-count (+ 1 moccur-buffer-match-count))))

    (<span class="keyword elisp">save-excursion</span>
      (end-of-line)
      (<span class="keyword elisp">if</span> (re-search-backward moccur-line-number-regexp (line-beginning-position) t)
          (setq moccur-line (buffer-substring
                             (match-beginning 1)
                             (match-end 1)))
        (setq moccur-line <span class="string">"1"</span>)))
    (<span class="keyword elisp">if</span> (and moccur-buffer-name
             (get-buffer moccur-buffer-name)
             (buffer-live-p (get-buffer moccur-buffer-name)))
        ()
      (setq moccur-view-other-window-nobuf nil))))

(<span class="keyword">defun</span> <span class="function">moccur-color-check-view</span> ()
  <span class="string">"If a matched buffer exists, the buffer is displayed."</span>
  (<span class="keyword elisp">if</span> (and moccur-buffer-name
           (get-buffer moccur-buffer-name))
      (<span class="keyword elisp">progn</span>
        (set-buffer (get-buffer moccur-buffer-name))
        (<span class="keyword elisp">if</span> moccur-overlays
            ()
          (moccur-color-view))
        (set-buffer moccur-mocur-buffer))))

(<span class="keyword">defun</span> <span class="function">moccur-view-file</span> ()
  <span class="string">"Display the matched buffer to other window."</span>
  (<span class="keyword elisp">if</span> (string= moccur-before-buffer-name moccur-buffer-name)
      (moccur-color-check-view)
    (<span class="keyword elisp">if</span> moccur-current-line-overlays
        (<span class="keyword elisp">progn</span>
          (delete-overlay moccur-current-line-overlays)
          (setq moccur-overlays nil)))
    (moccur-color-view))

  (switch-to-buffer-other-window
   (get-buffer moccur-buffer-name))
  (goto-line (string-to-number moccur-line))
  (<span class="keyword elisp">if</span> (re-search-forward moccur-regexp-color (line-end-position) t)
      ()
    (goto-line (string-to-number moccur-line)))

  <span class="comment">;; color</span>
  (moccur-color-current-line)

  (setq moccur-before-buffer-name moccur-buffer-name)
  (switch-to-buffer-other-window moccur-mocur-buffer))

(<span class="keyword">defun</span> <span class="function">moccur-scroll-file</span> (arg)
  <span class="string">"Scroll up the matched buffer.
If ARG is non-nil, scroll down the buffer."</span>
  (switch-to-buffer-other-window
   (get-buffer moccur-buffer-name))
  (<span class="keyword elisp">condition-case</span> nil
      (<span class="keyword elisp">if</span> arg
          (scroll-down)
        (scroll-up))
    (<span class="warning">error</span>
     nil))

  <span class="comment">;; color</span>
  (moccur-color-current-line)

  (setq moccur-before-buffer-name moccur-buffer-name)
  (switch-to-buffer-other-window moccur-mocur-buffer))

(<span class="keyword">defun</span> <span class="function">moccur-internal-beginning-of-buffer</span> (arg)
  <span class="string">"Begging-of-buffer in the matched buffer.
Argument ARG If non-nil, `<span class="constant important">end-of-buffer</span>'."</span>
  (switch-to-buffer-other-window
   (get-buffer moccur-buffer-name))
  (<span class="keyword elisp">condition-case</span> nil
      (<span class="keyword elisp">if</span> arg
          (goto-char (point-max))
        (goto-char (point-min)))
    (<span class="warning">error</span>
     nil))

  <span class="comment">;; color</span>
  (moccur-color-current-line)

  (setq moccur-before-buffer-name moccur-buffer-name)
  (switch-to-buffer-other-window moccur-mocur-buffer))

<span class="comment">;;;; minibuffer</span>
(<span class="keyword">defvar</span> <span class="variable">dmoccur-default-word</span> nil)
(<span class="keyword">defun</span> <span class="function">moccur-set-default-word</span> ()
  <span class="string">"Set default word to regexp."</span>
  (<span class="keyword elisp">cond</span>
   ((and dmoccur-project-name
         (nth 5 (assoc (car dmoccur-project-name) dmoccur-list)))
    (setq dmoccur-default-word
          (<span class="keyword elisp">if</span> (nth 5 (assoc (car dmoccur-project-name) dmoccur-list))
              (nth 5 (assoc (car dmoccur-project-name) dmoccur-list))
            <span class="string">""</span>))
    (<span class="keyword elisp">if</span> (stringp dmoccur-default-word)
        dmoccur-default-word
      (<span class="keyword elisp">condition-case</span> err
          (funcall dmoccur-default-word)
        (<span class="warning">error</span>
         <span class="string">""</span>))))
   ((and
     (or (and (boundp 'mark-active) mark-active)
         (and (fboundp 'region-exists-p) (region-exists-p)))
     (&lt; (- (region-end) (region-beginning)) 50))
    (buffer-substring-no-properties
     (region-beginning) (region-end)))
   ((&gt; (length (thing-at-point 'symbol)) 0)
    (thing-at-point 'symbol))
   ((&gt; (length (thing-at-point 'word)) 0)
    (thing-at-point 'word))
   (t
    (<span class="keyword elisp">if</span> (and regexp-history (stringp (car regexp-history)))
        (car regexp-history)
      <span class="string">""</span>))))

(<span class="keyword">defun</span> <span class="function">moccur-regexp-read-from-minibuf</span> ()
  <span class="string">"Read regexp from minibuffer."</span>
  (<span class="keyword elisp">let</span> (default input lst (search-lst nil) dmoccur-default-word)
    (setq default (moccur-set-default-word))
    (setq input
          (read-from-minibuffer
           <span class="string">"List lines matching regexp: "</span>
           <span class="comment">;;(format <span class="string">"List lines matching regexp (default `<span class="constant important">%s</span>'): "</span></span>
           <span class="comment">;;        default)</span>
           (cons default 0) <span class="comment">;; initial string</span>
           nil nil
           'regexp-history
           (<span class="keyword elisp">if</span> (and (boundp 'running-xemacs) running-xemacs)
               nil
             default)
           (<span class="keyword elisp">if</span> (and (boundp 'running-xemacs) running-xemacs)
               default
             color-moccur-default-ime-status)))
    (<span class="keyword cl">when</span> (and (equal input <span class="string">""</span>) default)
      (setq input default)
      (setq regexp-history (cons input regexp-history)))
    (<span class="keyword cl">when</span> moccur-split-word
      (setq lst (moccur-split-string input))
      (<span class="keyword elisp">while</span> lst
        (<span class="keyword elisp">if</span> (string-match <span class="string">"^b:"</span> (car lst))
            ()
          (setq search-lst (cons (car lst) search-lst)))
        (setq lst (cdr lst)))
      (<span class="keyword elisp">if</span> (= 0 (length search-lst))
          (<span class="warning">error</span> <span class="string">"Input search string"</span>)))
    input))

<span class="comment">;;;; search function</span>
(<span class="keyword">defun</span> <span class="function">moccur-search-line</span> (regexp)
  <span class="string">"Corresponding to re-search-line.
Argument REGEXP REGEXP to search."</span>
  (<span class="keyword elisp">let</span> ((lst moccur-regexp-list)
        (split-match 0))
    <span class="comment">;; if return nil, moccur search next buffer</span>
    (<span class="keyword elisp">cond</span>
     ((and moccur-split-word lst)
      <span class="comment">;; search method for split-word</span>
      (<span class="keyword elisp">while</span> (and (not (= (length moccur-regexp-list) split-match))
                  (re-search-forward regexp nil t))
        (setq lst moccur-regexp-list)
        (setq split-match 0)
        (<span class="keyword elisp">while</span> lst
          (<span class="keyword elisp">save-excursion</span>
            (beginning-of-line)
            (<span class="keyword elisp">if</span> (re-search-forward (car lst) (line-end-position) t)
                (setq split-match (+ split-match 1)))
            (setq lst (cdr lst)))))
      (<span class="keyword elisp">if</span> (= (length moccur-regexp-list) split-match)
          t
        nil))
     (t
      <span class="comment">;; defualt</span>
      (re-search-forward regexp nil t)))))

(make-variable-buffer-local 'moccur-buffer-position)
(<span class="keyword">defun</span> <span class="function">moccur-search-buffer</span> (<span class="type">&amp;optional</span> regexp currbuf name)
  <span class="string">"Search REGEXP in CURRBUF.
If NAME exists, `<span class="constant important">moccur-search-buffer</span>' works as grep."</span>
  (<span class="keyword elisp">let</span> ((match-str nil) fname)
    (set-buffer currbuf)
    (setq moccur-buffer-position (point))

    <span class="comment">;;(make-local-hook 'after-change-functions)</span>
    <span class="comment">;;(remove-hook 'after-change-functions 'moccur-remove-overlays)</span>
    (add-hook 'after-change-functions 'moccur-remove-overlays-on-all-buffers nil t)

    (goto-char (point-min))

    (moccur-special-word-call-initialize-function)

    (<span class="keyword elisp">while</span> (moccur-search-line regexp)
      (<span class="keyword cl">when</span> (moccur-special-word-call-check-function)
        (setq moccur-matches (+ moccur-matches 1))
        (<span class="keyword elisp">let</span>* ((linenum (count-lines
                         (<span class="keyword elisp">save-restriction</span> (widen) (point-min)) (point)))
               (tag (format <span class="string">"\n%5d "</span> linenum)))
          (put-text-property 0 (length tag) 'face 'font-lock-constant-face tag)
          (setq
           match-str
           (cons
            (concat tag
                    (buffer-substring
                     (line-beginning-position) (line-end-position)))
            match-str))
          (forward-line nil))))
    (setq match-str (reverse match-str))
    (<span class="keyword elisp">save-excursion</span>
      (set-buffer moccur-mocur-buffer)
      (<span class="keyword elisp">if</span> (not match-str)
          nil
        (<span class="keyword elisp">let</span> (pt)
          (<span class="keyword elisp">cond</span>
           (name
            (setq pt (point))
            (insert <span class="string">"Buffer: File (grep): "</span>)
            (put-text-property pt (point) 'face 'font-lock-keyword-face)
            (setq pt (point))
            (insert name <span class="string">"\n"</span>)
            (put-text-property pt (point) 'face 'font-lock-variable-name-face))
           (t
            (<span class="keyword elisp">if</span> (buffer-file-name currbuf)
                (setq fname (buffer-file-name currbuf))
              (setq fname <span class="string">"Not file"</span>))
            (setq pt (point))
            (insert <span class="string">"Buffer: "</span>)
            (put-text-property pt (point) 'face 'font-lock-keyword-face)
            (setq pt (point))
            (insert (buffer-name currbuf))
            (put-text-property pt (point) 'face 'font-lock-variable-name-face)
            (setq pt (point))
            (insert <span class="string">" File: "</span>)
            (put-text-property pt (point) 'face 'font-lock-keyword-face)
            (setq pt (point))
            (insert fname <span class="string">"\n"</span>)
            (put-text-property pt (point) 'face 'font-lock-variable-name-face))))

        (<span class="keyword elisp">while</span> match-str
          (insert (car match-str))
          (setq match-str (cdr match-str)))
        (insert <span class="string">"\n\n"</span>)
        t))))

(<span class="keyword">defvar</span> <span class="variable">moccur-searched-list</span> nil)
(<span class="keyword">defun</span> <span class="function">moccur-search</span> (regexp arg buffers)
  <span class="string">"Search REGEXP in BUFFERS (list).
If ARG is non-nil, also search buffer that doesn't have file name"</span>

  (<span class="keyword cl">when</span> (or
         (not regexp)
         (string= regexp <span class="string">""</span>))
    (<span class="warning">error</span> <span class="string">"No search word specified!"</span>))
  <span class="comment">;; initialize</span>
  (<span class="keyword elisp">let</span> ((lst
         (list
          regexp arg buffers)))
    (<span class="keyword elisp">if</span> (equal lst (car moccur-searched-list))
        ()
      (setq moccur-searched-list
            (cons
             (list
              regexp arg buffers)
             moccur-searched-list))))

  (setq moccur-special-word nil)
  (moccur-set-regexp)
  (moccur-set-regexp-for-color)

  <span class="comment">;; variable reset</span>
  (setq dmoccur-project-name nil)
  (setq moccur-matches 0)
  (setq moccur-match-buffers nil)
  (setq moccur-regexp-input regexp)
  (<span class="keyword elisp">if</span> (string= (car regexp-history) moccur-regexp-input)
      ()
    (setq regexp-history
          (cons moccur-regexp-input regexp-history)))

  (<span class="keyword elisp">save-excursion</span>
    (setq moccur-mocur-buffer (generate-new-buffer <span class="string">"*Moccur*"</span>))
    (set-buffer moccur-mocur-buffer)
    (moccur-insert-heading moccur-regexp-input)
    (setq moccur-buffers buffers)

    <span class="comment">;; search all buffers</span>
    (<span class="keyword elisp">while</span> buffers
      (<span class="keyword elisp">if</span> (and
           (car buffers)
           (buffer-live-p (car buffers))
           <span class="comment">;; if b<span class="builtin">:regexp</span> exists,</span>
           (<span class="keyword elisp">if</span> (and moccur-file-name-regexp
                    moccur-split-word)
               (string-match moccur-file-name-regexp
                             (buffer-name (car buffers)))
             t))
          (<span class="keyword elisp">if</span> (and (not arg)
                   (not (buffer-file-name (car buffers))))
              (setq buffers (cdr buffers))
            (<span class="keyword elisp">if</span> (moccur-search-buffer (car moccur-regexp-list) (car buffers))
                (setq moccur-match-buffers
                      (cons (car buffers) moccur-match-buffers)))
            (setq buffers (cdr buffers)))
        <span class="comment">;; illegal buffer</span>
        (setq buffers (cdr buffers))))
    (<span class="keyword elisp">if</span> (&gt; moccur-matches 0)
        (<span class="keyword elisp">save-excursion</span>
          (set-buffer moccur-mocur-buffer)
          (delete-other-windows)
          (moccur-mode)
          <span class="comment">;; highlight Moccur buffer</span>
          (moccur-buffer-color)
          (setq buffer-undo-list nil)

          (moccur-ee-start)
          (setq buffer-undo-list nil)

          <span class="comment">;; move cursor to the first matching text</span>
          (set-buffer moccur-mocur-buffer)

          (goto-char (point-min))
          (forward-line 2)

          (beginning-of-line)
          (re-search-forward moccur-line-number-regexp nil t)
          (re-search-forward (car moccur-regexp-list) nil t)

          (moccur-get-info)

          (setq moccur-before-buffer-name moccur-buffer-name)
          (moccur-color-view)

          <span class="comment">;; preview file</span>
          (moccur-view-file)
          (pop-to-buffer moccur-mocur-buffer)
          (message <span class="string">"%d matches"</span> moccur-matches)
          t)
      (message <span class="string">"no matches"</span>)
      (setq moccur-searched-list
            (cdr moccur-searched-list))
      (moccur-kill-buffer t)
      (moccur-remove-overlays-on-all-buffers)
      nil)))

(<span class="keyword">defun</span> <span class="function">moccur-search-undo</span> ()
  (interactive)
  (moccur-setup)
  (setq moccur-last-command 'moccur-search-undo)
  (<span class="keyword cl">unless</span> (nth 1 moccur-searched-list)
    (<span class="warning">error</span> <span class="string">"No undo information"</span>))
  (setq moccur-searched-list (cdr moccur-searched-list))
  (<span class="keyword elisp">let</span> ((buffers (car (cdr (cdr (car moccur-searched-list)))))
        (regexp (car (car moccur-searched-list)))
        (arg (car (cdr (car moccur-searched-list)))))
    <span class="comment">;; sort</span>
    (setq buffers (sort buffers moccur-buffer-sort-method))
    (moccur-search regexp arg buffers)))

(<span class="keyword">defun</span> <span class="function">moccur-search-update</span> ()
  (interactive)
  (moccur-setup)
  (setq moccur-last-command 'moccur-search-update)
  (<span class="keyword elisp">let</span> ((buffers (car (cdr (cdr (car moccur-searched-list)))))
        (regexp (car (car moccur-searched-list)))
        (arg (car (cdr (car moccur-searched-list)))))
    <span class="comment">;; sort</span>
    (setq buffers (sort buffers moccur-buffer-sort-method))
    (moccur-search regexp arg buffers)))

<span class="comment">;;;; search word</span>
(<span class="keyword">defun</span> <span class="function">moccur-split-string</span> (string <span class="type">&amp;optional</span> separators)
  <span class="string">"Splits STRING into substrings where there are matches for SEPARATORS.
Each match for SEPARATORS is a splitting point.
The substrings between the splitting points are made into a list
which is returned.
If SEPARATORS is absent, it defaults to \"[ ]+\".

But if substring is invalid regexp, this function doesn't split into
substrings.

Example:
 moccur split string -&gt; '(\"moccur\" \"split\" \"string\")
 moccur [a-z ]+ search -&gt; '(\"moccur\" \"[a-z ]+\" \"search\")"</span>

  <span class="comment">;; strip whitespace from end of string</span>
  (setq string
        (substring
         string
         0
         (string-match <span class="string">"[ ]+$"</span> string)))
  (<span class="keyword elisp">while</span> (string-match <span class="string">"^[ ]+"</span> string)
    (setq string
          (substring
           string
           1)))
  (<span class="keyword elisp">let</span>* ((rexp (or separators <span class="string">"[ ]+"</span>))
         (lst (split-string string rexp))
         (new-lst nil)
         (current-regexp nil)
         (regexp-p nil)
         (regexp nil))

    (<span class="keyword cl">when</span> (and
           moccur-split-word
           (assoc (car lst) moccur-special-word-list)
           (&gt; (length lst) 1))
      (setq moccur-regexp-list (cdr moccur-regexp-list))
      (setq moccur-special-word (car lst))
      (setq lst (cdr lst)))

    (<span class="keyword elisp">while</span> lst
      (setq current-regexp (concat
                            regexp
                            (<span class="keyword elisp">if</span> regexp
                                <span class="string">" "</span>)
                            (car lst)))
      (setq regexp nil)
      (setq lst (cdr lst))
      (setq regexp-p t)
      (<span class="keyword elisp">condition-case</span> err
          (string-match current-regexp <span class="string">"test"</span>)
        (<span class="warning">error</span>
         (setq regexp-p nil)))

      (<span class="keyword elisp">cond</span>
       ((and moccur-use-keyword
             regexp-p
             (assoc current-regexp moccur-search-keyword-alist))
        (setq new-lst
              (cons
               (cdr (assoc current-regexp moccur-search-keyword-alist))
               new-lst)))
       (regexp-p
        (setq new-lst (cons current-regexp new-lst)))
       (t
        (setq regexp (concat current-regexp
                             (<span class="keyword elisp">if</span> regexp <span class="string">" "</span>) regexp)))))

    (<span class="keyword elisp">if</span> regexp
        (setq new-lst
              (append new-lst
                      (mapcar '(<span class="keyword elisp">lambda</span> (string)
                                 (<span class="keyword elisp">if</span> (and moccur-use-keyword
                                          (assoc string moccur-search-keyword-alist))
                                     (cdr (assoc string moccur-search-keyword-alist))
                                   (regexp-quote string)))
                              (split-string regexp)))))
    (<span class="keyword elisp">if</span> (and
         (not new-lst)
         (not regexp))
        (<span class="warning">error</span> <span class="string">"Invalid regexp"</span>))

    (setq new-lst (reverse new-lst))

    new-lst))

(<span class="keyword">defun</span> <span class="function">moccur-word-split</span> (regexp <span class="type">&amp;optional</span> norestrict)
  <span class="string">"Splits REGEXP into substrings."</span>
  (setq moccur-file-name-regexp nil)
  (<span class="keyword elisp">let</span> ((lst (moccur-split-string regexp))
        (regexp-list nil))

    (<span class="keyword elisp">while</span> lst
      (<span class="keyword elisp">if</span> (and (not norestrict)
               moccur-split-word (string-match <span class="string">"^b:"</span> (car lst)))
          (setq moccur-file-name-regexp
                (cons (substring (car lst) 2) moccur-file-name-regexp))
        (setq regexp-list
              (cons
               (<span class="keyword elisp">if</span> moccur-use-migemo
                   (<span class="keyword elisp">cond</span>
                    ((string-match <span class="string">"^r:"</span> (car lst))
                     (substring (car lst) 2))
                    ((not (string= (car lst) (regexp-quote (car lst))))
                     (car lst))
                    (t
                     (migemo-get-pattern (car lst))))
                 (car lst))
               regexp-list)))
      (setq lst (cdr lst)))

    (<span class="keyword elisp">if</span> (and moccur-split-word moccur-file-name-regexp)
        (<span class="keyword elisp">progn</span>
          (setq lst moccur-file-name-regexp)
          (setq moccur-file-name-regexp (concat <span class="string">"\\("</span> (car lst)))
          (setq lst (cdr lst))
          (<span class="keyword elisp">while</span> lst
            (setq moccur-file-name-regexp
                  (concat moccur-file-name-regexp
                          <span class="string">"\\|"</span>
                          (car lst)))
            (setq lst (cdr lst)))
          (setq moccur-file-name-regexp
                (concat moccur-file-name-regexp <span class="string">"\\)"</span>))))
    regexp-list))

(<span class="keyword">defun</span> <span class="function">moccur-set-regexp</span> ()
  <span class="string">"Set `<span class="constant important">moccur-regexp-list</span>' and `<span class="constant important">moccur-file-name-regexp</span>' from user regexp."</span>
  (setq moccur-regexp-list nil)
  (setq moccur-file-name-regexp nil)

  (<span class="keyword elisp">if</span> moccur-split-word
      (setq moccur-regexp-list (moccur-word-split regexp))
    (<span class="keyword elisp">if</span> moccur-use-migemo
        (<span class="keyword elisp">cond</span>
         ((string-match <span class="string">"^r:"</span> regexp)
          (setq moccur-regexp-list (list (substring regexp 2))))
         ((not (string= regexp (regexp-quote regexp)))
          (setq moccur-regexp-list (list regexp)))
         (t
          (setq moccur-regexp-list (list (migemo-get-pattern regexp)))))
      (setq moccur-regexp-list (list regexp)))))

(<span class="keyword">defun</span> <span class="function">moccur-set-regexp-for-color</span> ()
  <span class="string">"Make regexp for coloring up."</span>
  (<span class="keyword elisp">let</span> ((list (cdr moccur-regexp-list)))
    (<span class="keyword elisp">if</span> moccur-split-word
        (<span class="keyword elisp">progn</span>
          (setq moccur-regexp-color (concat
                                     <span class="string">"\\("</span> (car moccur-regexp-list)))
          (<span class="keyword elisp">while</span> list
            (setq moccur-regexp-color
                  (concat moccur-regexp-color
                          <span class="string">"\\|"</span>
                          (car list)))
            (setq list (cdr list)))
          (setq moccur-regexp-color
                (concat moccur-regexp-color <span class="string">"\\)"</span>)))
      (setq moccur-regexp-color (car moccur-regexp-list)))))

<span class="comment">;;;; moccur special word</span>
<span class="comment">;;;;; basic functions</span>
(<span class="keyword">defun</span> <span class="function">moccur-special-word-call-initialize-function</span> ()
  <span class="string">"Initialize function for special word function."</span>
  (<span class="keyword elisp">cond</span>
   ((and moccur-split-word
         moccur-special-word)
    (<span class="keyword elisp">if</span> (nth 1 (assoc moccur-special-word moccur-special-word-list))
        (funcall
         (nth 1 (assoc moccur-special-word moccur-special-word-list)))))
   (t
    (<span class="keyword elisp">if</span> (nth 1 (assoc t moccur-special-word-list))
        (funcall
         (nth 1 (assoc t moccur-special-word-list)))))))

(<span class="keyword">defun</span> <span class="function">moccur-special-word-call-check-function</span> ()
  <span class="string">"Function to check whether the matched text is acceptable."</span>
  (<span class="keyword elisp">cond</span>
   ((and moccur-split-word
         moccur-special-word)
    (or
     (and (assoc moccur-special-word moccur-special-word-list)
          (nth 2 (assoc moccur-special-word moccur-special-word-list))
          (funcall
           (nth 2 (assoc moccur-special-word moccur-special-word-list))))
     (not
      (assoc moccur-special-word moccur-special-word-list))
     (not
      (nth 2 (assoc moccur-special-word moccur-special-word-list)))))
   (t
    (<span class="keyword elisp">if</span> (nth 2 (assoc t moccur-special-word-list))
        (funcall
         (nth 2 (assoc t moccur-special-word-list)))
      t))))

<span class="comment">;;;;; functions</span>
(<span class="keyword">defun</span> <span class="function">moccur-face-check</span> (facename)
  <span class="string">"Check whether the face of current point is FACENAME."</span>
  (<span class="keyword elisp">let</span> ((face
         (<span class="keyword elisp">save-excursion</span>
           (forward-char -1)
           (get-text-property (point) 'face))))
    (<span class="keyword elisp">cond</span>
     ((listp face)
      (memq facename face))
     (t
      (string=
       facename face)))))

(make-variable-buffer-local 'moccur-fontlock-buffer)
(<span class="keyword">defun</span> <span class="function">moccur-face-initialization</span> ()
  <span class="string">"Call 'font-lock-default-fontify-buffer'."</span>
  (<span class="keyword elisp">let</span> ((font-lock-support-mode 'fast-lock-mode))
    (<span class="keyword elisp">if</span> moccur-fontlock-buffer
        ()
      (setq moccur-fontlock-buffer t)
      (font-lock-default-fontify-buffer))))

(<span class="keyword">defun</span> <span class="function">moccur-default-initial-function</span> ()
  ())

(<span class="keyword">defun</span> <span class="function">moccur-default-check-function</span> ()
  t)

(<span class="keyword">defun</span> <span class="function">moccur-comment-check</span> ()
  (moccur-face-check 'font-lock-comment-face))

(<span class="keyword">defun</span> <span class="function">moccur-string-check</span> ()
  (moccur-face-check 'font-lock-string-face))

(<span class="keyword">defun</span> <span class="function">moccur-function-check</span> ()
  (<span class="keyword elisp">cond</span>
   ((string= major-mode 'texinfo-mode)
    (moccur-face-check 'texinfo-heading-face))
   ((string= major-mode 'change-log-mode)
    (moccur-face-check 'change-log-file-face))
   ((string= major-mode 'outline-mode)
    (<span class="keyword elisp">if</span> (<span class="keyword elisp">save-excursion</span>
          (re-search-backward
           (concat <span class="string">"^"</span> outline-regexp) (line-beginning-position) t))
        t
      nil))
   (t
    (or
     (moccur-face-check 'font-lock-function-name-face)
     (moccur-face-check 'font-lock-variable-name-face))
    )))

<span class="comment">;;;; ee</span>
(<span class="keyword">defun</span> <span class="function">moccur-ee-start</span> ()
  (<span class="keyword elisp">let</span> ((str (buffer-substring-no-properties
              (line-beginning-position) (line-end-position))))
    (<span class="keyword cl">when</span> (and (not (<span class="keyword">featurep</span> '<span class="constant">allout</span>))
               moccur-use-ee
               (buffer-live-p (get-buffer <span class="string">"*Moccur*"</span>)))
      (<span class="keyword elisp">if</span> (buffer-live-p (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>))
          (kill-buffer (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>)))

      (switch-to-buffer (get-buffer <span class="string">"*Moccur*"</span>))
      (ee-outline)
      (re-search-forward (regexp-quote str) nil t)
      (moccur-mode t)
      <span class="comment">;;(use-local-map moccur-mode-map)</span>
      (setq moccur-mocur-buffer (current-buffer))
      <span class="comment">;; highlight Moccur buffer</span>
      (moccur-buffer-color))))

(<span class="keyword">defun</span> <span class="function">moccur-switch-buffer</span> (buf)
  (interactive)
  (<span class="keyword cl">when</span> (and moccur-use-ee (not (<span class="keyword">featurep</span> '<span class="constant">allout</span>)))
    (<span class="keyword elisp">if</span> (string= 'normal buf)
        (<span class="keyword elisp">if</span> (get-buffer <span class="string">"*Moccur*"</span>)
            (switch-to-buffer (get-buffer <span class="string">"*Moccur*"</span>)))
      (<span class="keyword elisp">if</span> (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>)
          (switch-to-buffer (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>))))))

<span class="comment">;;;; interactive</span>
(<span class="keyword">defun</span> <span class="function">moccur</span> (regexp arg)
  <span class="string">"Show all lines of all buffers containing a match for REGEXP.
The lines are shown in a buffer named *Moccur*.
It serves as a menu to find any of the occurrences in this buffer.
\\[<span class="constant important">describe-mode</span>] in that buffer will explain how."</span>
  (interactive (list (moccur-regexp-read-from-minibuf)
                     current-prefix-arg))

  (moccur-setup)
  (setq moccur-last-command 'moccur)

  (<span class="keyword elisp">let</span> ((buffers (moccur-filter-buffers (buffer-list))))
    <span class="comment">;; sort</span>
    (setq buffers (sort buffers moccur-buffer-sort-method))
    (moccur-search regexp arg buffers)))

(<span class="keyword">defun</span> <span class="function">moccur-grep-correspond-ext-p</span> (filename list)
  (<span class="keyword elisp">let</span> ((ret nil))
    (<span class="keyword elisp">while</span> list
      (<span class="keyword cl">when</span> (string-match (car list) filename)
        (setq ret t))
      (setq list (cdr list)))
    ret))

<span class="comment">;;; moccur-grep</span>
(<span class="keyword">defun</span> <span class="function">moccur-grep-xdoc</span>2txt-p (filename)
  (<span class="keyword elisp">if</span> (and
       moccur-run-meadow-onwin
       moccur-use-xdoc2txt
       (moccur-grep-correspond-ext-p
        filename moccur-grep-xdoc2txt-exts))
      t
    nil))

(<span class="keyword">defun</span> <span class="function">moccur-search-file-p</span> (filename)
  (and
   (file-readable-p filename)
   (or
    (and
     (not moccur-grep-xdoc2txt-maximum-size)
     (moccur-file-size&lt; filename moccur-grep-xdoc2txt-maximum-size)
     (moccur-grep-xdoc2txt-p filename))
    (and
     (moccur-file-size&lt; filename dmoccur-maximum-size)
     (not (dmoccur-in-list-p filename
                             dmoccur-exclusion-mask))))))

(<span class="keyword">defun</span> <span class="function">moccur-search-files-init</span> (regexp files)
  (setq moccur-special-word nil)
  (moccur-set-regexp)
  (moccur-set-regexp-for-color)

  (setq moccur-matches 0)
  (setq moccur-regexp-input regexp)
  (<span class="keyword elisp">if</span> (string= (car regexp-history) moccur-regexp-input)
      ()
    (setq regexp-history
          (cons moccur-regexp-input regexp-history))))

(<span class="keyword">defun</span> <span class="function">moccur-files-insert-xdoc</span>2txt-file (filename)
  (<span class="keyword elisp">let</span> ((fn (concat
             (expand-file-name
              (make-temp-name <span class="string">"xdoc2"</span>)
              temporary-file-directory)
             <span class="string">"."</span>
             (file-name-extension filename)))
        (str nil)
        (coding-system-for-write 'binary)
        (coding-system-for-read 'binary))
    (set-buffer-file-coding-system 'euc-japan)
    (copy-file filename fn t)
    (insert
     (shell-command-to-string
      (concat
       <span class="string">"cd "</span> (file-name-directory fn) <span class="string">"<span class="comment">;"</span></span>
       <span class="string">"xdoc2txt"</span> <span class="string">" -e "</span> (file-name-nondirectory fn))))
    (delete-file fn)
    (decode-coding-region (point-min) (point-max)
                          'euc-jp)
    (goto-char (point-min))
    (<span class="keyword elisp">while</span> (re-search-forward <span class="string">"\r"</span> nil t)
      (delete-region (match-beginning 0)
                     (match-end 0)))
    (goto-char (point-min))
    (<span class="keyword elisp">while</span> (re-search-forward <span class="string">"\\([\n ]+\\)\n[ ]*\n"</span> nil t)
      (delete-region (match-beginning 1)
                     (match-end 1)))
    (goto-char (point-min))))

(<span class="keyword">defun</span> <span class="function">moccur-search-all-files</span> (files)
  (<span class="keyword elisp">let</span> ((total (length files))
        (num 0))
    (<span class="keyword elisp">condition-case</span> err
        (<span class="keyword elisp">while</span> files
          (setq num (+ num 1))
          (<span class="keyword elisp">with-temp-buffer</span>
            (<span class="keyword cl">when</span>
                (or
                 (string= moccur-last-command 'moccur-grep)
                 (and
                  (not (string= moccur-last-command 'moccur-grep))
                  (moccur-search-file-p (car files))))
              (message <span class="string">"Searching %d/%d (%d matches) : %s ..."</span>
                       num total moccur-matches
                       (file-relative-name (car files) default-directory))
              (<span class="keyword elisp">condition-case</span> err
                  (<span class="keyword elisp">cond</span>
                   ((moccur-grep-correspond-ext-p
                     (car files) moccur-grep-xdoc2txt-exts)
                    (moccur-files-insert-xdoc2txt-file (car files)))
                   (t
                    (<span class="keyword elisp">if</span> moccur-grep-search-file-pos
                        (insert-file-contents (car files) nil 0 moccur-grep-search-file-pos)
                      (insert-file-contents (car files)))))
                (<span class="warning">error</span>
                 ())))
            (widen)
            (moccur-search-buffer (car moccur-regexp-list) (current-buffer)
                                  (car files)))
          (setq files (cdr files)))
      (quit
       ()))))

(<span class="keyword">defun</span> <span class="function">moccur-search-files</span> (regexp files)
  <span class="string">"Search REGEXP in FILES (list)."</span>

  <span class="comment">;; initialize</span>
  (moccur-search-files-init regexp files)

  (<span class="keyword elisp">save-excursion</span>
    (setq moccur-mocur-buffer (generate-new-buffer <span class="string">"*Moccur*"</span>))
    (set-buffer moccur-mocur-buffer)
    (moccur-insert-heading moccur-regexp-input)

    <span class="comment">;; search all buffers</span>
    (moccur-search-all-files files)
    (message <span class="string">"Searching done!"</span>)
    (<span class="keyword elisp">if</span> (&gt; moccur-matches 0)
        (<span class="keyword elisp">progn</span>
          (set-buffer moccur-mocur-buffer)
          (delete-other-windows)
          (moccur-grep-mode)
          <span class="comment">;; highlight Moccur buffer</span>
          (moccur-buffer-color)
          (setq buffer-undo-list nil)

          <span class="comment">;; move cursor to the first matching text</span>
          (set-buffer moccur-mocur-buffer)
          <span class="comment">;;(setq moccur-view-other-window nil)</span>

          (pop-to-buffer moccur-mocur-buffer)
          (goto-char (point-min))

          (make-local-variable 'moccur-xdoc2txt-buffers)
          (setq moccur-xdoc2txt-buffers nil)

          (message <span class="string">"%d matches"</span> moccur-matches)
          t)
      (message <span class="string">"no matches"</span>)
      (moccur-kill-buffer t)
      (moccur-remove-overlays-on-all-buffers)
      nil)))

(<span class="keyword">defun</span> <span class="function">moccur-grep-binary-file-view</span> (file)
  (<span class="keyword elisp">cond</span>
   ((and (rassoc file moccur-xdoc2txt-buffers)
         (car (rassoc file moccur-xdoc2txt-buffers))
         (buffer-live-p (get-buffer (car (rassoc file moccur-xdoc2txt-buffers)))))
    (car (rassoc file moccur-xdoc2txt-buffers)))
   (t
    (<span class="keyword elisp">save-current-buffer</span>
      (<span class="keyword elisp">let</span> ((dummy-buff (generate-new-buffer
                         (concat <span class="string">"xdoc2txt:"</span>
                                 (file-name-nondirectory
                                  file))))
            (coding-system-for-write 'binary)
            (coding-system-for-read 'binary))
        (set-buffer dummy-buff)
        (<span class="keyword elisp">let</span> ((fn (concat
                   (expand-file-name
                    (make-temp-name <span class="string">"xdoc2"</span>)
                    temporary-file-directory)
                   <span class="string">"."</span>
                   (file-name-extension file)))
              (str nil)
              )
          (set-buffer-file-coding-system 'euc-japan)

          (copy-file file fn t)
          (insert
           (shell-command-to-string
            (concat
             <span class="string">"cd "</span> (file-name-directory fn) <span class="string">"<span class="comment">;"</span></span>
             <span class="string">"xdoc2txt"</span> <span class="string">" -e "</span> (file-name-nondirectory fn))))
          (decode-coding-region (point-min) (point-max)
                                'euc-jp)
          (goto-char (point-min))
          (<span class="keyword elisp">while</span> (re-search-forward <span class="string">"\r"</span> nil t)
            (delete-region (match-beginning 0)
                           (match-end 0)))
          (goto-char (point-min))
          (<span class="keyword elisp">while</span> (re-search-forward <span class="string">"\\([\n ]+\\)\n[ ]*\n"</span> nil t)
            (delete-region (match-beginning 1)
                           (match-end 1)))
          (delete-file fn)
          )
        (setq buffer-read-only t)
        (goto-char (point-min))
        (view-mode t)
        (buffer-name dummy-buff)
        )))))

(<span class="keyword">defun</span> <span class="function">moccur-grep-sync-kill-buffers</span> ()
  (<span class="keyword elisp">let</span> (buf)
    (<span class="keyword cl">when</span> moccur-grep-buffer-list
      (<span class="keyword elisp">while</span> moccur-grep-buffer-list
        (setq buf (car moccur-grep-buffer-list))
        (setq moccur-grep-buffer-list
              (cdr moccur-grep-buffer-list))
        (<span class="keyword elisp">if</span> (and (buffer-live-p buf)
                 (not (buffer-modified-p buf)))
            (kill-buffer buf)))
      (delete-other-windows))))

(add-hook 'kill-buffer-hook
          '(<span class="keyword elisp">lambda</span> ()
             (<span class="keyword elisp">if</span> (string= major-mode 'moccur-grep-mode)
                 (moccur-grep-sync-kill-buffers))))

(<span class="keyword">defun</span> <span class="function">moccur-grep-goto</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> (file line str buf)
    (<span class="keyword elisp">save-excursion</span>
      (<span class="keyword elisp">if</span> (re-search-backward moccur-grep-buffer-heading-regexp nil t)
          (setq file
                (buffer-substring-no-properties
                 (match-beginning 1)
                 (match-end 1)))))
    (<span class="keyword elisp">save-excursion</span>
      (end-of-line)
      (<span class="keyword elisp">if</span> (re-search-backward moccur-line-number-regexp nil t)
          (setq line
                (string-to-number
                 (buffer-substring-no-properties
                  (match-beginning 1)
                  (match-end 1))))))
    (<span class="keyword cl">when</span> (and file line)
      (<span class="keyword elisp">cond</span>
       ((moccur-grep-xdoc2txt-p file)
        (setq buf (moccur-grep-binary-file-view file))
        (<span class="keyword cl">when</span> (not (assoc buf moccur-xdoc2txt-buffers))
          (setq moccur-xdoc2txt-buffers
                (cons
                 (cons buf file)
                 moccur-xdoc2txt-buffers)))
        (switch-to-buffer-other-window buf))
       (t
        (find-file-other-window file)))
      (widen)
      (goto-line line))))

(<span class="keyword">defun</span> <span class="function">moccur-grep-read-directory</span> ()
  (<span class="keyword elisp">let</span> ((dir default-directory))
    (setq dir
          (<span class="keyword elisp">if</span> (and (boundp 'running-xemacs) running-xemacs)
              (read-directory-name <span class="string">"Directory: "</span> dir)
            (read-file-name <span class="string">"Directory: "</span> nil nil t)))
    (<span class="keyword elisp">if</span> (and (file-exists-p dir)
             (file-directory-p  dir))
        (setq dir (file-name-as-directory dir))
      (setq dir (file-name-as-directory (file-name-directory dir)))
      (<span class="keyword elisp">if</span> (and (file-exists-p dir)
               (file-directory-p  dir))
          ()
        (<span class="warning">error</span> (format <span class="string">"No such directory %s"</span> dir))
        (sleep-for 1)
        (setq dir nil)))
    dir))

(<span class="keyword">defun</span> <span class="function">moccur-grep-read-regexp</span> (<span class="type">&amp;optional</span> mask)
  (<span class="keyword elisp">let</span> (regexp input (wd nil) (init nil) (pt 1))
    (<span class="keyword cl">when</span> moccur-grep-default-word-near-point
      <span class="comment">;; get a word near the point as default regexp string</span>
      (setq wd (thing-at-point 'symbol))
      (set-text-properties 0 (length wd) nil wd)
      <span class="comment">;; put point to the end of default word</span>
      (setq pt (1+ (length wd))))
    (setq init (cons (concat wd <span class="string">" "</span> mask) pt))
    (setq input
          (read-from-minibuffer <span class="string">"Input Regexp and FileMask: "</span> init))
    (moccur-split-string input <span class="string">" "</span>)))

(<span class="keyword">defun</span> <span class="function">moccur-grep</span> (dir inputs)
  (interactive
   (list (moccur-grep-read-directory)
         (moccur-grep-read-regexp moccur-grep-default-mask)))
  (moccur-setup)
  (setq moccur-last-command 'moccur-grep)

  (<span class="keyword elisp">let</span> (regexps mask files)
    (setq regexps
          (mapconcat 'concat
                     (<span class="keyword elisp">if</span> (= 1 (length inputs))
                         inputs
                       (reverse (cdr (reverse inputs))))
                     <span class="string">" "</span>))
    (setq mask
          (<span class="keyword elisp">if</span> (= 1 (length inputs))
              <span class="string">"."</span>
            (car (reverse inputs))))
    (setq files (directory-files dir t mask))
    (<span class="keyword elisp">let</span> (list)
      (<span class="keyword cl">dolist</span> (elt files)
        (<span class="keyword elisp">cond</span>
         ((file-directory-p elt)
          ())
         (t
          (push elt list))))
      (setq files (reverse list)))
    (moccur-search-files regexps files)
    ))

(<span class="keyword">defun</span> <span class="function">moccur-grep-find-subdir</span> (dir mask)
  (<span class="keyword elisp">let</span> ((files (cdr (cdr (directory-files dir t)))) (list) (plist))
    (<span class="keyword elisp">if</span> (not (moccur-search-file-p dir))
        (setq list nil)
      (<span class="keyword cl">dolist</span> (elt files)
        (<span class="keyword elisp">cond</span>
         ((and
           (not (string-match <span class="string">"^[.]+$"</span> (file-name-nondirectory elt)))
           (file-directory-p elt))
          (setq list (append (moccur-grep-find-subdir elt mask) list)))
         ((string-match <span class="string">"^[.]+$"</span> (file-name-nondirectory elt))
          ())
         ((string-match mask (file-name-nondirectory elt))
          (push elt list))
         (t ()))
        (<span class="keyword elisp">if</span> (not (eq list plist))
            (message <span class="string">"Listing %s ..."</span> (file-name-directory elt)))
        (setq plist list)))
    list))

(<span class="keyword">defun</span> <span class="function">moccur-grep-find</span> (dir inputs)
  (interactive
   (list (moccur-grep-read-directory)
         (moccur-grep-read-regexp moccur-grep-default-mask)))
  (moccur-setup)
  (setq moccur-last-command 'moccur-grep-find)

  (<span class="keyword elisp">let</span> (regexps
        mask (files nil)
        <span class="comment">;;(default-directory dir)</span>
        )
    (setq regexps
          (mapconcat 'concat
                     (<span class="keyword elisp">if</span> (= 1 (length inputs))
                         inputs
                       (reverse (cdr (reverse inputs))))
                     <span class="string">" "</span>))
    (setq mask
          (<span class="keyword elisp">if</span> (= 1 (length inputs))
              <span class="string">"."</span>
            (car (reverse inputs))))
    (message <span class="string">"Listing files..."</span>)
    (<span class="keyword elisp">cond</span>
     ((listp dir)
      (<span class="keyword elisp">while</span> dir
        (<span class="keyword elisp">cond</span>
         ((file-directory-p (car dir))
          (setq files (append
                       (reverse (moccur-grep-find-subdir (car dir) mask))
                       files)))
         (t
          (setq files (cons
                       (car dir)
                       files))))
        (setq dir (cdr dir))))
     (t
      (setq files (reverse (moccur-grep-find-subdir dir mask)))))
    (message <span class="string">"Listing files done!"</span>)
    (moccur-search-files regexps files)
    ))

<span class="comment">;;; dmoccur</span>
<span class="comment">;;;; utility</span>
(<span class="keyword">defun</span> <span class="function">dmoccur-in-list-p</span> (dir-name dir-name-regexps)
  (<span class="keyword elisp">let</span> ((<span class="keyword cl">case</span>-fold-search t))
    (<span class="keyword elisp">cond</span> ((null dir-name-regexps) nil)
          ((string-match  (car dir-name-regexps) dir-name) t)
          (t (dmoccur-in-list-p dir-name (cdr dir-name-regexps))))))

(<span class="keyword">defun</span> <span class="function">moccur-add-files-to-search-list</span> (files dir <span class="type">&amp;optional</span> norest recursive)
  (<span class="keyword elisp">let</span> ((buffers nil) (file-regexps dmoccur-recursive-ignore-dir)
        (file-ignore nil)
        file-name buf-name (cbuf (current-buffer))
        (enable-local-eval t))
    (<span class="keyword elisp">while</span> files
      (setq file-ignore nil)
      (setq file-regexps dmoccur-recursive-ignore-dir)
      (setq buf-name nil)
      (setq file-name (expand-file-name (car files) dir))

      (<span class="keyword elisp">while</span> file-regexps
        (<span class="keyword elisp">if</span> (string-match (car file-regexps) file-name)
            (setq file-ignore t))
        (setq file-regexps (cdr file-regexps)))
      (<span class="keyword cl">when</span> (not file-ignore)
        (<span class="keyword elisp">if</span> (file-directory-p file-name)
            (<span class="keyword elisp">cond</span>
             ((string= 'dired recursive)
              (setq buffers
                    (append
                     (moccur-add-files-to-search-list
                      (directory-files file-name) file-name norest nil)
                     buffers)))
             ((and recursive
                   (not (string= (expand-file-name <span class="string">"."</span> dir)
                                 file-name))
                   (not (string= (expand-file-name <span class="string">".."</span> dir)
                                 file-name)))
              (setq buffers
                    (append
                     (moccur-add-files-to-search-list
                      (directory-files file-name) file-name norest recursive)
                     buffers)))
             (t
              nil))
          (<span class="keyword elisp">if</span> (and
               (file-readable-p file-name)
               (or norest
                   (and
                    (moccur-file-size&lt; file-name dmoccur-maximum-size)
                    (dmoccur-in-list-p file-name dmoccur-mask-internal)
                    (not (dmoccur-in-list-p file-name
                                            dmoccur-exclusion-mask)))))
              (<span class="keyword elisp">progn</span>
                (<span class="keyword elisp">if</span> (get-file-buffer file-name)
                    (setq buf-name (get-file-buffer file-name))
                  (setq buf-name (find-file-noselect file-name)))
                (<span class="keyword elisp">if</span> (cdr file-name-history)
                    (setq file-name-history (cdr file-name-history)))
                (<span class="keyword elisp">save-current-buffer</span>
                  (set-buffer buf-name)
                  (setq dmoccur-buffer-project dmoccur-project-name))
                (<span class="keyword elisp">if</span> buf-name
                    (setq buffers (cons buf-name buffers)))))))
      (setq files (cdr files)))
    buffers))

(<span class="keyword">defun</span> <span class="function">moccur-add-directory-to-search-list</span> (dir)
  (setq dmoccur-recursive-ignore-dir nil)
  (<span class="keyword elisp">let</span> ((buffers nil))
    (<span class="keyword elisp">if</span> (listp dir)
        (<span class="keyword elisp">progn</span>
          (<span class="keyword elisp">let</span> ((recursive nil) (cdir nil))
            (<span class="keyword elisp">while</span> dir
              (setq cdir (eval (car (car dir))))
              (setq dmoccur-recursive-ignore-dir
                    (nth 2 (car dir)))
              (setq recursive
                    (nth 1 (car dir)))
              (setq buffers
                    (append
                     (<span class="keyword elisp">if</span> (file-directory-p cdir)
                         (moccur-add-files-to-search-list
                          (directory-files cdir) cdir nil recursive)
                       (moccur-add-files-to-search-list
                        (list cdir) (file-name-directory cdir) t))
                     buffers))
              (setq dir (cdr dir)))))
      (<span class="keyword elisp">let</span> ((files (directory-files dir)))
        (setq buffers
              (moccur-add-files-to-search-list
               files dir nil dmoccur-recursive-search))))
    (<span class="keyword elisp">let</span> (list)
      (<span class="keyword cl">dolist</span> (elt buffers)
        (<span class="keyword cl">unless</span> (member elt list)
          (push elt list)))
      (setq buffers list))
    buffers))

<span class="comment">;;;; minibuffer</span>
(<span class="keyword">defun</span> <span class="function">dmoccur-read-directory-from-minibuf</span> (default)
  (<span class="keyword elisp">let</span> ((dir nil))
    (<span class="keyword elisp">while</span> (not dir)
      (setq dir
            (<span class="keyword elisp">if</span> (and (boundp 'running-xemacs) running-xemacs)
                (read-directory-name <span class="string">"Directory: "</span> default)
              (read-file-name <span class="string">"Directory: "</span> default nil t)))
      <span class="comment">;;(read-file-name <span class="string">"Directory: "</span> nil nil t default)))</span>
      (<span class="keyword elisp">if</span> (and (file-exists-p dir)
               (file-directory-p  dir))
          (setq dir (file-name-as-directory dir))
        (setq dir (file-name-as-directory (file-name-directory dir)))
        (<span class="keyword elisp">if</span> (and (file-exists-p dir)
                 (file-directory-p  dir))
            ()
          (message <span class="string">"No such directory %s"</span> dir)
          (sleep-for 1)
          (setq dir nil))))
    dir))

(<span class="keyword">defun</span> <span class="function">dmoccur-read-project-name-from-minibuf</span> (arg)
  (<span class="keyword elisp">let</span> (input-name)
    (<span class="keyword elisp">if</span> (and dmoccur-buffer-project
             dmoccur-use-project
             (or
              (and
               (not arg)
               dmoccur-use-list)
              (and
               arg
               (not dmoccur-use-list))))
        (setq input-name (car dmoccur-buffer-project))
      (setq input-name
            (completing-read
             (concat
              <span class="string">"dmoccur name "</span>
              (<span class="keyword cl">when</span> (car dmoccur-list-history)
                (format <span class="string">"(default %s)"</span>
                        (car dmoccur-list-history)))
              <span class="string">" : "</span>)
             (<span class="keyword elisp">let</span> (list)
               (<span class="keyword cl">dolist</span> (elt (append
                             dmoccur-project-list
                             dmoccur-list))
                 (<span class="keyword cl">unless</span> (assoc (car elt) list)
                   (push elt list)))
               list)
             nil nil nil 'dmoccur-list-history
             (<span class="keyword elisp">if</span> (car dmoccur-list-history)
                 (car dmoccur-list-history)
               nil))))
    input-name))

(<span class="keyword">defun</span> <span class="function">dmoccur-set-sub-directory</span> (name dir)
  (<span class="keyword elisp">let</span> ((lst nil)
        (subdir
         (<span class="keyword elisp">if</span> (listp dir)
             (eval (nth 0 (car dir)))
           (eval dir))))
    (setq lst (mapcar '(<span class="keyword elisp">lambda</span> (file)
                         (<span class="keyword elisp">if</span> (and (not (string-match <span class="string">"\\.+$"</span> file))
                                  (file-directory-p file))
                             (file-name-nondirectory file)))
                      (directory-files
                       subdir t)))
    (setq lst (delq nil lst))

    (<span class="keyword elisp">if</span> (and dmoccur-buffer-project
             dmoccur-use-project)
        (setq subdir (car (cdr dmoccur-buffer-project)))
      (setq subdir (concat
                    (file-name-as-directory subdir)
                    (completing-read
                     <span class="string">"dmoccur sub directory : "</span>
                     (mapcar 'list lst)
                     nil t)
                    <span class="string">"/"</span>)))
    (<span class="keyword elisp">if</span> (listp dir)
        (list (cons subdir (nthcdr 1 (car dir))))
      subdir)))

(<span class="keyword">defun</span> <span class="function">dmoccur-set-project</span> (arg)
  (setq dmoccur-project-name nil)
  (<span class="keyword elisp">let</span> (input-name name lst dir)
    (setq input-name (dmoccur-read-project-name-from-minibuf arg))

    (<span class="keyword elisp">if</span> (assoc input-name dmoccur-project-list)
        (setq name (nth 1 (assoc input-name dmoccur-project-list)))
      (setq name input-name))
    (<span class="keyword elisp">cond</span>
     ((assoc name dmoccur-list)
      <span class="comment">;; default directory</span>
      (setq dir
            (<span class="keyword elisp">if</span> (listp (nth 1 (assoc name dmoccur-list)))
                (<span class="keyword elisp">condition-case</span> err
                    (eval (nth 1 (assoc name dmoccur-list)))
                  (<span class="warning">error</span>
                   (nth 1 (assoc name dmoccur-list))))
              (file-name-as-directory
               (eval (nth 1 (assoc name dmoccur-list))))))

      <span class="comment">;; 'sub option</span>
      (<span class="keyword elisp">if</span> (string= 'sub (nth 3 (assoc name dmoccur-list)))
          (<span class="keyword elisp">if</span> (and (listp dir)
                   (not (= (length dir) 1)))
              (<span class="warning">error</span> <span class="string">"Multiple directory exists!"</span>)
            (setq dir
                  (dmoccur-set-sub-directory name dir))))

      <span class="comment">;; if buffer-project exists, use it</span>
      (<span class="keyword elisp">if</span> (and dmoccur-buffer-project
               dmoccur-use-project)
          ()
        (<span class="keyword elisp">if</span> (string= 'dir (nth 3 (assoc name dmoccur-list)))
            (<span class="keyword elisp">if</span> (and (listp dir)
                     (not (= (length dir) 1)))
                (<span class="warning">error</span> <span class="string">"Multiple directory exists!"</span>)
              (<span class="keyword elisp">if</span> (listp dir)
                  (setq dir
                        (list
                         (cons
                          (dmoccur-read-directory-from-minibuf
                           (eval (car (car dir)))) (cdr (car dir)))))
                (setq dir (dmoccur-read-directory-from-minibuf dir))))))

      <span class="comment">;; set current project</span>
      (setq dmoccur-project-name
            (<span class="keyword elisp">if</span> (listp dir)
                (cons name dir)
              (cons name (cons dir dmoccur-project-name))))

      <span class="comment">;; mask</span>
      (setq dmoccur-mask-internal (nth 2 (assoc name dmoccur-list))))

     ((assoc input-name dmoccur-project-list)
      (<span class="keyword elisp">if</span> (and (string= name input-name)
               (string-match <span class="string">"^dmoccur"</span> name))
          (setq name <span class="string">"dmoccur"</span>))
      (<span class="keyword elisp">if</span> (or (string= 'dir (nth 3 (assoc name dmoccur-list)))
              (string= 'sub (nth 3 (assoc name dmoccur-list)))
              (string= name <span class="string">"dmoccur"</span>))
          (setq dir
                (substring input-name
                           (<span class="keyword elisp">progn</span>
                             (string-match (concat name <span class="string">"-"</span>) input-name)
                             (match-end 0))))
        (setq dir (nth 1 (assoc name dmoccur-project-list))))
      (setq dmoccur-project-name (cons name dir)))
     (t
      (setq dmoccur-list-history (cdr dmoccur-list-history))
      (<span class="warning">error</span> <span class="string">"Input correct name!"</span>)))
    dir))

(<span class="keyword">defun</span> <span class="function">dmoccur-read-from-minibuf</span> (arg)
  (<span class="keyword elisp">let</span> ((dir nil))
    (<span class="keyword elisp">if</span> (or arg
            dmoccur-use-list)
        (setq dir (dmoccur-set-project arg))
      (setq dir default-directory)
      (setq dmoccur-mask-internal dmoccur-mask)
      (setq dir (dmoccur-read-directory-from-minibuf dir)))
    dir))

<span class="comment">;;;; interactive</span>
(<span class="keyword">defun</span> <span class="function">dmoccur</span> (dir regexp arg)
  <span class="string">"Show all lines of all buffers containing a match for REGEXP.
The lines are shown in a buffer named *Moccur*.
It serves as a menu to find any of the occurrences in this buffer.
\\[<span class="constant important">describe-mode</span>] in that buffer will explain how."</span>
  (interactive (list (dmoccur-read-from-minibuf current-prefix-arg)
                     (moccur-regexp-read-from-minibuf)
                     current-prefix-arg))
  (moccur-setup)

  (setq moccur-last-command 'dmoccur)
  (<span class="keyword elisp">let</span>* ((list-name (<span class="keyword elisp">if</span> (car dmoccur-project-name)
                        (car dmoccur-project-name) <span class="string">"dmoccur"</span>))
         (buffers
          (moccur-add-directory-to-search-list dir))
         (name
          (list
           (<span class="keyword elisp">if</span> (and
                (or dmoccur-use-list arg)
                (or
                 (not (or (string= 'dir
                                   (nth 3 (assoc list-name dmoccur-list)))
                          (string= 'sub
                                   (nth 3 (assoc list-name dmoccur-list)))))
                 (assoc list-name dmoccur-project-list)))
               list-name
             (concat list-name <span class="string">"-"</span>
                     (<span class="keyword elisp">if</span> (listp dir) (expand-file-name (car (car dir)))
                       (expand-file-name dir))))
           list-name)))
    <span class="comment">;; sort</span>
    (setq buffers (sort buffers moccur-buffer-sort-method))

    (<span class="keyword elisp">if</span> (assoc (car name) dmoccur-project-list)
        (<span class="keyword elisp">progn</span>
          (<span class="keyword elisp">let</span>* ((lst (assoc (car name) dmoccur-project-list))
                 (old-buffers (nthcdr 2 lst)))
            (setq dmoccur-project-list (delete lst dmoccur-project-list))
            (setq name
                  (append name
                          (<span class="keyword elisp">let</span> ((list nil))
                            (<span class="keyword cl">dolist</span> (elt (append
                                          old-buffers
                                          buffers))
                              (<span class="keyword cl">unless</span> (memq elt list)
                                (push elt list)))
                            list)))))
      (setq name
            (append name
                    buffers)))

    (setq dmoccur-project-list
          (cons
           name
           dmoccur-project-list))

    (<span class="keyword elisp">if</span> (nth 4 (assoc list-name dmoccur-list))
        (<span class="keyword elisp">let</span>* ((conf (<span class="keyword elisp">if</span> (nth 4 (assoc list-name dmoccur-list))
                         (nth 4 (assoc list-name dmoccur-list))
                       nil))
               (moccur-use-migemo (car conf))
               (moccur-split-word (car (cdr conf))))
          (moccur-search regexp arg buffers))
      (moccur-search regexp arg buffers))))

(<span class="keyword">defun</span> <span class="function">clean-dmoccur-buffers</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> (name buffers lst)
    (setq name (completing-read
                (concat
                 <span class="string">"dmoccur name "</span>
                 <span class="string">" : "</span>)
                dmoccur-project-list))

    (setq buffers (nthcdr 2 (assoc name dmoccur-project-list)))
    (setq lst (list
               (nth 1 (assoc name dmoccur-project-list))))
    (setq lst (append (list name) lst))
    (setq lst (append lst buffers))

    (setq dmoccur-project-list (delete lst dmoccur-project-list))
    (<span class="keyword elisp">while</span> buffers
      (<span class="keyword elisp">if</span> (and (car buffers)
               (buffer-live-p (car buffers))
               (get-buffer (car buffers))
               (not (buffer-modified-p (car buffers))))
          (kill-buffer (car buffers)))
      (setq buffers (cdr buffers)))))

<span class="comment">;;; call moccur</span>
<span class="comment">;;;; dired</span>
(<span class="keyword">defun</span> <span class="function">dired-do-moccur-by-moccur</span> (regexp arg)
  (<span class="keyword elisp">let</span> ((buffers (moccur-add-files-to-search-list
                  (funcall (<span class="keyword elisp">cond</span> ((fboundp 'dired-get-marked-files) <span class="comment">; GNU Emacs</span>
                                  'dired-get-marked-files)
                                 ((fboundp 'dired-mark-get-files) <span class="comment">; XEmacs</span>
                                  'dired-mark-get-files))
                           t nil) default-directory t 'dired))
        (buff nil))
    (moccur-search regexp arg buffers)
    (setq moccur-last-command 'dired-do-moccur)
    (<span class="keyword cl">when</span> kill-buffer-after-dired-do-moccur
      (<span class="keyword elisp">while</span> buffers
        (setq buff (car buffers))
        (<span class="keyword elisp">if</span> (memq buff moccur-match-buffers)
            ()
          (<span class="keyword elisp">if</span> (memq buff moccur-buffers-before-moccur)
              (delq buff buffers)
            (kill-buffer buff)))
        (setq buffers (cdr buffers))))))

(<span class="keyword">defun</span> <span class="function">dired-do-moccur-by-mgrep</span> (regexp arg)
  (<span class="keyword elisp">let</span>* ((files (funcall (<span class="keyword elisp">cond</span> ((fboundp 'dired-get-marked-files) <span class="comment">; GNU Emacs</span>
                                'dired-get-marked-files)
                               ((fboundp 'dired-mark-get-files) <span class="comment">; XEmacs</span>
                                'dired-mark-get-files))
                         t nil))
         (buff nil))
    (moccur-grep-find files
                      (moccur-split-string
                       (concat regexp <span class="string">" ."</span>) <span class="string">" "</span>))
    (setq moccur-last-command 'dired-do-moccur)))

(<span class="keyword">defun</span> <span class="function">dired-do-moccur</span> (regexp arg)
  <span class="string">"Show all lines of all buffers containing a match for REGEXP.
The lines are shown in a buffer named *Moccur*.
It serves as a menu to find any of the occurrences in this buffer.
\\[<span class="constant important">describe-mode</span>] in that buffer will explain how."</span>
  (interactive (list (moccur-regexp-read-from-minibuf)
                     current-prefix-arg))
  (moccur-setup)
  (setq moccur-buffers-before-moccur (buffer-list))
  (<span class="keyword elisp">if</span> arg
      (dired-do-moccur-by-moccur regexp arg)
    (dired-do-moccur-by-mgrep regexp arg)))

<span class="comment">;;;; kill-buffer when moccur-quit</span>
(<span class="keyword">defadvice</span> <span class="function">moccur-quit</span> (before moccur-quit-kill-buffers activate)
  (<span class="keyword elisp">let</span> ((buffers moccur-match-buffers)
        (buff nil)
        (mocc-window (selected-window))
        (mocc-buffer (window-buffer (selected-window))))
    (<span class="keyword elisp">while</span> moccur-xdoc2txt-buffers
      (<span class="keyword cl">when</span> (buffer-live-p
             (get-buffer (car (car moccur-xdoc2txt-buffers))))
        (kill-buffer (car (car moccur-xdoc2txt-buffers))))
      (setq moccur-xdoc2txt-buffers (cdr moccur-xdoc2txt-buffers)))
    (<span class="keyword elisp">while</span> buffers
      (setq buff (car buffers))
      (<span class="keyword cl">when</span> (and (eq moccur-last-command 'dired-do-moccur)
                 kill-buffer-after-dired-do-moccur
                 (buffer-live-p buff)
                 (buffer-name buff))
        (select-window (next-window mocc-window))
        (set-window-buffer (selected-window) buff)
        (<span class="keyword elisp">if</span> (and (buffer-file-name buff)
                 (buffer-modified-p buff)
                 (y-or-n-p (concat <span class="string">"Buffer "</span>
                                   (buffer-name buff)
                                   <span class="string">" modified. Save it? "</span>)))
            (save-buffer)
          (set-buffer-modified-p nil)) <span class="comment">;; mark as not modified</span>
        (display-buffer mocc-buffer)
        (select-window mocc-window)
        (<span class="keyword elisp">if</span> (memq buff moccur-buffers-before-moccur)
            (delq buff buffers)
          (kill-buffer buff)))
      (setq buffers (cdr buffers))))
  nil)

<span class="comment">;;;; Buffer-menu-moccur</span>
(<span class="keyword">defun</span> <span class="function">Buffer-menu-moccur</span> (regexp arg)
  (interactive (list (moccur-regexp-read-from-minibuf)
                     current-prefix-arg))
  (setq arg 1)
  (moccur-kill-buffer t)
  (setq moccur-last-command 'buffer-menu-moccur)
  (<span class="keyword elisp">let</span> ((marked-buffer) (marked-files))
    (goto-char (point-min))
    (<span class="keyword elisp">while</span> (search-forward <span class="string">"\n&gt;"</span> nil t)
      (setq marked-buffer (Buffer-menu-buffer t))
      (setq marked-files (cons marked-buffer marked-files)))
    (moccur-search regexp arg marked-files)))

(<span class="keyword cl">unless</span> (<span class="keyword">featurep</span> '<span class="constant">ibuffer</span>)
  (<span class="keyword">defun</span> <span class="function">ibuffer-map-marked-lines</span> (func))
  (<span class="keyword">defun</span> <span class="function">ibuffer-do-occur</span> (regexp <span class="type">&amp;optional</span> nlines)))
(<span class="keyword">defadvice</span> <span class="function">ibuffer-do-occur</span>
  (around ibuffer-menu-moccur activate)
  (interactive (list (moccur-regexp-read-from-minibuf)
                     current-prefix-arg))
  (setq moccur-last-command 'buffer-menu-moccur)
  (<span class="keyword elisp">let</span> (arg (regexp (ad-get-arg 0)))
    (setq arg 1)
    (moccur-kill-buffer t)
    (<span class="keyword elisp">let</span> ((marked-buffers nil))
      (ibuffer-map-marked-lines
       #'(<span class="keyword elisp">lambda</span> (buf mark beg end)
           (push buf marked-buffers)))
      (ibuffer-unmark-all 62)
      (moccur-search regexp arg marked-buffers))))

<span class="comment">;;; moccur mode</span>
<span class="comment">;;;; keybind</span>
(<span class="keyword">defvar</span> <span class="variable">moccur-mode-map</span> ())
(<span class="keyword">defun</span> <span class="function">moccur-set-key</span> ()
  (<span class="keyword elisp">let</span> ((map (make-sparse-keymap)))
    (define-key map <span class="string">"e"</span> 'moccur-toggle-buffer)
    (define-key map <span class="string">"\C-c\C-c"</span> 'moccur-mode-goto-occurrence)
    (define-key map <span class="string">"\C-m"</span> 'moccur-mode-goto-occurrence)
    (define-key map <span class="string">"d"</span> 'moccur-kill-line)
    (define-key map <span class="string">"\C-k"</span> 'moccur-kill-line)
    (define-key map <span class="string">"\M-d"</span> 'moccur-mode-kill-file)
    (define-key map <span class="string">"/"</span> 'moccur-mode-undo)
    <span class="comment">;;(define-key map <span class="string">"f"</span> 'moccur-flush-lines) ;; M-x</span>
    <span class="comment">;;(define-key map <span class="string">""</span> 'moccur-keep-lines) ;; M-x</span>
    (define-key map <span class="string">"q"</span> 'moccur-quit)
    (define-key map <span class="string">"n"</span> 'moccur-next)
    (define-key map <span class="string">"p"</span> 'moccur-prev)
    (define-key map <span class="string">"j"</span> 'moccur-next)
    (define-key map <span class="string">"k"</span> 'moccur-prev)
    (define-key map '[wheel-down] 'moccur-next)
    (define-key map '[wheel-up] 'moccur-prev)
    (define-key map <span class="string">"s"</span> 'moccur-narrow-down)
    (define-key map <span class="string">"u"</span> 'moccur-search-undo)
    (define-key map <span class="string">"g"</span> 'moccur-search-update)
    (define-key map '[down] 'moccur-next)
    (define-key map '[up] 'moccur-prev)
    (define-key map <span class="string">"t"</span> 'moccur-toggle-view)
    (define-key map <span class="string">"b"</span> 'moccur-file-scroll-down)
    (define-key map <span class="string">" "</span> 'moccur-file-scroll-up)
    <span class="comment">;;     (define-key map <span class="string">"b"</span> 'moccur-scroll-down)</span>
    <span class="comment">;;     (define-key map <span class="string">" "</span> 'moccur-scroll-up)</span>
    (define-key map <span class="string">"\M-v"</span> 'moccur-scroll-down)
    (define-key map <span class="string">"\C-v"</span> 'moccur-scroll-up)
    (define-key map <span class="string">"h"</span> 'moccur-next-file)
    (define-key map <span class="string">"l"</span> 'moccur-prev-file)
    (define-key map <span class="string">"\M-n"</span> 'moccur-next-file)
    (define-key map <span class="string">"\M-p"</span> 'moccur-prev-file)
    (define-key map '[M-wheel-down] 'moccur-next-file)
    (define-key map '[M-wheel-up] 'moccur-prev-file)

    (define-key map '[down-mouse-1] 'moccur-mouse-select1)

    (define-key map <span class="string">"&lt;"</span> 'moccur-file-beginning-of-buffer)
    (define-key map <span class="string">"&gt;"</span> 'moccur-file-end-of-buffer)

    (<span class="keyword elisp">condition-case</span> nil
        (<span class="keyword elisp">progn</span>
          (<span class="keyword">require</span> '<span class="constant">moccur-edit</span>)
          (define-key map <span class="string">"r"</span> 'moccur-edit-mode-in)
          (define-key map <span class="string">"\C-x\C-q"</span> 'moccur-edit-mode-in)
          (define-key map <span class="string">"\C-c\C-i"</span> 'moccur-edit-mode-in))
      (<span class="warning">error</span>
       nil))
    map))

(<span class="keyword elisp">if</span> moccur-mode-map
    ()
  (setq moccur-mode-map (make-sparse-keymap))
  (setq moccur-mode-map (moccur-set-key)))

(<span class="keyword">defvar</span> <span class="variable">moccur-ee-mode-map</span> ())
(<span class="keyword">defun</span> <span class="function">moccur-set-key-ee</span> ()
  (<span class="keyword elisp">let</span> ((map (make-sparse-keymap)))
    (setq map (moccur-set-key))
    <span class="comment">;; Expansion visibility</span>
    (define-key map <span class="string">"+"</span> 'ee-view-expansion-show)
    (define-key map <span class="string">"-"</span> 'ee-view-expansion-hide)
    (define-key map <span class="string">"="</span> 'ee-view-expansion-show)
    <span class="comment">;; on some keyboards <span class="string">"="</span> is on same key as <span class="string">"+"</span>, but typed w/o shift</span>
    (define-key map <span class="string">"*"</span> 'ee-view-expansion-show-subtree)
    <span class="comment">;;(define-key map <span class="string">"/"</span> 'ee-view-expansion-hide-subtree)</span>
    <span class="comment">;; Help</span>
    (define-key map <span class="string">"?"</span> 'describe-mode)
    <span class="comment">;;(define-key map <span class="string">"r"</span></span>
    <span class="comment">;; (<span class="keyword elisp">lambda</span> () (interactive) (message <span class="string">"%S"</span> (ee-view-record-get))))</span>
    <span class="comment">;;(define-key map <span class="string">"\C-c\C-hr"</span></span>
    <span class="comment">;; (<span class="keyword elisp">lambda</span> () (interactive) (message <span class="string">"%S"</span> (ee-view-record-get))))</span>
    <span class="comment">;; Buffer</span>
    (define-key map <span class="string">"g"</span> 'ee-view-buffer-revert)
    (define-key map <span class="string">"\C-x\C-s"</span> 'ee-data-file-save)
    <span class="comment">;; outline-like key bindings</span>
    (define-key map <span class="string">"\C-c\C-n"</span> 'ee-view-expansion-next-visible)
    (define-key map <span class="string">"\C-c\C-p"</span> 'ee-view-expansion-prev-visible)
    (define-key map <span class="string">"\C-c\C-f"</span> 'ee-view-expansion-next-same-level)
    (define-key map <span class="string">"\C-c\C-b"</span> 'ee-view-expansion-prev-same-level)
    (define-key map <span class="string">"\C-c\C-u"</span> 'ee-view-expansion-up)
    (define-key map <span class="string">"\C-c\C-i"</span> 'ee-view-expansion-show-children)
    (define-key map <span class="string">"\C-c\C-s"</span> 'ee-view-expansion-show-subtree)
    (define-key map <span class="string">"\C-c\C-d"</span> 'ee-view-expansion-hide-subtree)
    (define-key map <span class="string">"\C-c\C-t"</span> 'ee-view-expansion-hide-body)
    (define-key map <span class="string">"\C-c\C-a"</span> 'ee-view-expansion-show-all)
    (define-key map <span class="string">"\C-c\C-l"</span> 'ee-view-expansion-hide-leaves)
    (define-key map <span class="string">"\C-c\C-k"</span> 'ee-view-expansion-show-branches)
    (define-key map <span class="string">"\C-c\C-q"</span> 'ee-view-expansion-hide-sublevels)
    (define-key map <span class="string">"\C-c\C-o"</span> 'ee-view-expansion-hide-other)
    <span class="comment">;; dired-like key bindings</span>
    (define-key map <span class="string">"$"</span> 'ee-view-expansion-show-or-hide)
    <span class="comment">;;     (define-key map <span class="string">"&gt;"</span> 'ee-view-expansion-next)</span>
    <span class="comment">;;     (define-key map <span class="string">"&lt;"</span> 'ee-view-expansion-prev)</span>
    (define-key map <span class="string">"^"</span> 'ee-view-expansion-up)
    (define-key map [(meta ?o)] 'ee-view-filter-omit)
    (define-key map [down-mouse-1] 'ee-mouse-navigation)
    (define-key map [right] 'ee-view-expansion-show-or-next)
    (define-key map [left] 'ee-view-expansion-hide-or-up-or-prev)
    (define-key map [(meta up)] 'ee-view-expansion-prev-sibling)
    (define-key map [(meta down)] 'ee-view-expansion-next-sibling)
    (define-key map [(meta right)] 'ee-view-expansion-up)
    (define-key map [(meta left)] 'ee-view-expansion-down)
    (define-key map [(control ?+)] 'ee-view-expansion-show-all)
    (define-key map [(control ?-)] 'ee-view-expansion-hide-all)
    map))

(<span class="keyword elisp">if</span> moccur-ee-mode-map
    ()
  (setq moccur-ee-mode-map (make-sparse-keymap))
  (setq moccur-ee-mode-map (moccur-set-key-ee)))

<span class="comment">;;;; utility</span>
(<span class="keyword">defun</span> <span class="function">moccur-outline-level</span> ()
  (<span class="keyword elisp">if</span> (looking-at <span class="string">"\\(^Buffer: \\)"</span>)
      0
    (<span class="keyword elisp">if</span> (looking-at <span class="string">"\\(^[ ]*[0-9]+ \\)"</span>)
        1)))

<span class="comment">;;;; re-search function</span>
(<span class="keyword">defun</span> <span class="function">moccur-narrow-down-get-targets</span> (target-regexp target-type)
  (<span class="keyword elisp">let</span> ((<span class="keyword cl">case</span>-fold-search t)
        (targets nil) target-name)
    (<span class="keyword elisp">save-excursion</span>
      (set-buffer (get-buffer <span class="string">"*Moccur*"</span>))
      (goto-char (point-min))
      (<span class="keyword elisp">while</span> (re-search-forward target-regexp nil t)
        (setq target-name (buffer-substring-no-properties
                           (match-beginning 1)
                           (match-end 1)))
        (<span class="keyword elisp">if</span> (equal target-type 'file)
            (setq targets (cons target-name targets))
          (<span class="keyword elisp">if</span> (get-buffer target-name)
              (setq targets (cons
                             (get-buffer target-name) targets)))))
        targets)))

(<span class="keyword">defun</span> <span class="function">moccur-narrow-down-get-buffers</span>()
  (moccur-narrow-down-get-targets moccur-buffer-heading-regexp 'buffer))

(<span class="keyword">defun</span> <span class="function">moccur-narrow-down-get-files</span>()
  (moccur-narrow-down-get-targets moccur-grep-buffer-heading-regexp 'file))

<span class="comment">;;;; functions</span>
(<span class="keyword">defun</span> <span class="function">moccur-narrow-down</span> (regexp arg)
  <span class="string">"Show all lines of all buffers containing a match for REGEXP.
The lines are shown in a buffer named *Moccur*.
It serves as a menu to find any of the occurrences in this buffer.
\\[<span class="constant important">describe-mode</span>] in that buffer will explain how."</span>
  (interactive (list (moccur-regexp-read-from-minibuf)
                     current-prefix-arg))

  (setq moccur-mocur-buffer (current-buffer))
  (setq moccur-last-command 'moccur-narrow-down)
  (<span class="keyword elisp">if</span> (equal major-mode 'moccur-grep-mode)
      (<span class="keyword elisp">let</span> ((files (reverse (moccur-narrow-down-get-files))))
        (moccur-setup)
        (moccur-search-files regexp files))
    (<span class="keyword elisp">let</span> ((buffers (reverse (moccur-narrow-down-get-buffers))))
      (moccur-setup)
      (moccur-search regexp arg buffers))))

(<span class="keyword">defun</span> <span class="function">moccur-mode-goto-occurrence</span> ()
  <span class="string">"Go to the line this occurrence was found in, in the buffer it was found in."</span>
  (interactive)
  <span class="comment">;;    (<span class="keyword elisp">if</span> (not (and moccur-view-other-window</span>
  <span class="comment">;;            moccur-view-other-window-nobuf))</span>
  <span class="comment">;;        (moccur-view-file)</span>
  (setq moccur-mocur-buffer (current-buffer))
  (<span class="keyword elisp">if</span> (not (eq major-mode 'moccur-mode))
      (<span class="warning">error</span> <span class="string">"This is no moccur buffer"</span>)
    (<span class="keyword elisp">let</span> ((beg nil)
          (line nil)
          (lineno nil)
          (dstbuf nil))
      (moccur-remove-overlays-on-all-buffers)
      (<span class="keyword elisp">save-excursion</span>
        (beginning-of-line 1)
        (setq beg (point))
        (end-of-line 1)
        (setq line (buffer-substring beg (point)))
        (<span class="keyword elisp">if</span> (or (string-match <span class="string">"^[ ]*[0-9]* "</span> line)
                (string-match <span class="string">"^[-+ ]*Buffer: "</span> line))
            (<span class="keyword elisp">progn</span>
              (<span class="keyword elisp">if</span> (string-match <span class="string">"^[-+ ]*Buffer: "</span> line)
                  (setq lineno nil)
                (setq lineno (car (read-from-string line))))
              (<span class="keyword elisp">if</span> (re-search-backward <span class="string">"^[-+ ]*Buffer: "</span>)
                  (<span class="keyword elisp">progn</span>
                    (search-forward <span class="string">"Buffer: "</span>)
                    (setq beg (point))
                    (search-forward <span class="string">" File:"</span>)
                    (setq line (buffer-substring beg (- (point) 6)))
                    (setq dstbuf (get-buffer line))
                    (<span class="keyword elisp">if</span> (not dstbuf)
                        (message <span class="string">"buffer: &lt;%s&gt; doesn't exist anymore"</span> line)))
                (<span class="warning">error</span> <span class="string">"What did you do with the header?!"</span>)))
          (<span class="warning">error</span> <span class="string">"This is no occurrence line!"</span>)))
      (<span class="keyword elisp">if</span> dstbuf
          (<span class="keyword elisp">progn</span>
            (<span class="keyword elisp">if</span> lineno
                (message <span class="string">"selecting &lt;%s&gt; line %d"</span> line lineno)
              (message <span class="string">"selecting &lt;%s&gt;"</span> line))
            (pop-to-buffer dstbuf)
            (<span class="keyword elisp">if</span> lineno
                (goto-line lineno))
            (<span class="keyword elisp">if</span> moccur-kill-buffer-after-goto
                (moccur-kill-buffer nil))
            (delete-other-windows))))))

(<span class="keyword">defun</span> <span class="function">moccur-toggle-buffer</span> ()
  (interactive)
  (<span class="keyword cl">when</span> (and moccur-use-ee (not (<span class="keyword">featurep</span> '<span class="constant">allout</span>)))
    (<span class="keyword elisp">let</span> ((str
           (<span class="keyword elisp">progn</span>
             (<span class="keyword elisp">save-excursion</span>
               (<span class="keyword elisp">if</span> (and (not (and (boundp 'running-xemacs) running-xemacs))
                        transient-mark-mode mark-active)
                   (goto-char (region-beginning)))
               (beginning-of-line)
               (re-search-forward <span class="string">"[<span class="negation">^</span>-+ ]"</span> nil t)
               (regexp-quote
                (buffer-substring-no-properties
                 (- (point) 1) (line-end-position)))))))
      (<span class="keyword elisp">if</span> (string-match <span class="string">"ee"</span> (buffer-name (current-buffer)))
          (<span class="keyword elisp">if</span> (buffer-live-p (get-buffer <span class="string">"*Moccur*"</span>))
              (switch-to-buffer (get-buffer <span class="string">"*Moccur*"</span>)))
        (<span class="keyword elisp">if</span> (buffer-live-p (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>))
            (switch-to-buffer (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>))))
      (goto-char (point-min))
      (<span class="keyword elisp">condition-case</span> err
          (re-search-forward str)
        (<span class="warning">error</span>
         nil))
      )))

(<span class="keyword">defun</span> <span class="function">moccur-mouse-select</span>1 (e)
  (interactive <span class="string">"e"</span>)
  (mouse-set-point e)
  (<span class="keyword elisp">save-excursion</span>
    (beginning-of-line)
    (moccur-next 0)))

(<span class="keyword">defun</span> <span class="function">moccur-mouse-goto-occurrence</span> (e)
  (interactive <span class="string">"e"</span>)
  (mouse-set-point e)
  (<span class="keyword elisp">save-excursion</span>
    (beginning-of-line)
    (moccur-mode-goto-occurrence)))

(<span class="keyword">defun</span> <span class="function">moccur-next</span> (arg)
  (interactive <span class="string">"p"</span>)
  (setq moccur-mocur-buffer (current-buffer))
  (<span class="keyword elisp">if</span> arg
      (forward-line arg)
    (forward-line 1))
  (beginning-of-line)

  (<span class="keyword elisp">if</span> (and moccur-use-ee (not (<span class="keyword">featurep</span> '<span class="constant">allout</span>))
           (<span class="keyword elisp">let</span> (end)
             (<span class="keyword elisp">save-excursion</span>
               (<span class="keyword elisp">if</span> (re-search-backward <span class="string">"^\\([-+ ]*\\)Buffer:"</span> nil t)
                   (<span class="keyword elisp">if</span> (string-match <span class="string">"+"</span>
                                     (buffer-substring-no-properties
                                      (match-beginning 1) (match-end 1)))
                       t
                     nil)
                 t))))
      (<span class="keyword elisp">progn</span>
        (re-search-forward <span class="string">"^\\([-+ ]*\\)Buffer:"</span> nil t)
        (beginning-of-line))
    (<span class="keyword cl">when</span> (re-search-forward moccur-line-number-regexp nil t)
      (<span class="keyword elisp">save-restriction</span>
        (narrow-to-region (point) (line-end-position))
        (re-search-forward (car moccur-regexp-list) nil t))))
  (moccur-get-info)
  (<span class="keyword elisp">if</span> (and moccur-view-other-window
           moccur-view-other-window-nobuf
           moccur-following-mode-toggle)
      (moccur-view-file)))

(<span class="keyword">defun</span> <span class="function">moccur-prev</span> (arg)
  (interactive <span class="string">"p"</span>)
  (setq moccur-mocur-buffer (current-buffer))
  (<span class="keyword elisp">if</span> arg
      (forward-line (* -1 arg))
    (forward-line -1))
  (end-of-line)

  (<span class="keyword elisp">if</span> (and moccur-use-ee
           (not (<span class="keyword">featurep</span> '<span class="constant">allout</span>))
           (<span class="keyword elisp">let</span> (end)
             (<span class="keyword elisp">save-excursion</span>
               (<span class="keyword elisp">if</span> (re-search-backward <span class="string">"^\\([-+ ]*\\)Buffer:"</span> nil t)
                   (<span class="keyword elisp">if</span> (string-match <span class="string">"+"</span>
                                     (buffer-substring-no-properties
                                      (match-beginning 1) (match-end 1)))
                       t
                     nil)
                 nil))))
      (re-search-backward <span class="string">"^\\([-+ ]*\\)Buffer:"</span> nil t)
    (end-of-line)
    (<span class="keyword elisp">if</span> (re-search-backward moccur-line-number-regexp nil t)
      (<span class="keyword elisp">save-restriction</span>
        (re-search-forward moccur-line-number-regexp nil t)
        (narrow-to-region (point) (line-end-position))
        (re-search-forward (car moccur-regexp-list) nil t))
      (beginning-of-line)))
  (moccur-get-info)
  (<span class="keyword elisp">if</span> (and moccur-view-other-window
           moccur-view-other-window-nobuf
           moccur-following-mode-toggle)
      (moccur-view-file)))

(<span class="keyword">defun</span> <span class="function">moccur-file-scroll-up</span> ()
  (interactive)
  (setq moccur-mocur-buffer (current-buffer))
  (moccur-get-info)
  (<span class="keyword elisp">if</span> (and moccur-view-other-window
           moccur-view-other-window-nobuf)
      (moccur-scroll-file nil)))

(<span class="keyword">defun</span> <span class="function">moccur-file-scroll-down</span> ()
  (interactive)
  (setq moccur-mocur-buffer (current-buffer))
  (moccur-get-info)
  (<span class="keyword elisp">if</span> (and moccur-view-other-window
           moccur-view-other-window-nobuf)
      (moccur-scroll-file t)))

(<span class="keyword">defun</span> <span class="function">moccur-file-beginning-of-buffer</span> ()
  (interactive)
  (setq moccur-mocur-buffer (current-buffer))
  (moccur-get-info)
  (<span class="keyword elisp">if</span> (and moccur-view-other-window
           moccur-view-other-window-nobuf)
      (moccur-internal-beginning-of-buffer nil)))

(<span class="keyword">defun</span> <span class="function">moccur-file-end-of-buffer</span> ()
  (interactive)
  (setq moccur-mocur-buffer (current-buffer))
  (moccur-get-info)
  (<span class="keyword elisp">if</span> (and moccur-view-other-window
           moccur-view-other-window-nobuf)
      (moccur-internal-beginning-of-buffer t)))

(<span class="keyword">defun</span> <span class="function">moccur-scroll-up</span> ()
  (interactive)
  (scroll-up)
  (<span class="keyword elisp">if</span> (boundp 'forward-visible-line)
      (forward-visible-line -1)
    (forward-line -1))
  (end-of-line)
  (moccur-next 1))

(<span class="keyword">defun</span> <span class="function">moccur-scroll-down</span> ()
  (interactive)
  (scroll-down)
  (<span class="keyword elisp">if</span> (boundp 'forward-visible-line)
      (forward-visible-line 1)
    (forward-line 1))
  (beginning-of-line)
  (moccur-prev 1))

(<span class="keyword">defun</span> <span class="function">moccur-next-file</span> ()
  (interactive)
  (<span class="keyword elisp">if</span> (re-search-forward <span class="string">"^[-+ ]*Buffer: "</span> nil t)
      (moccur-next 1)
    (goto-char (point-min))
    (moccur-next 1)))

(<span class="keyword">defun</span> <span class="function">moccur-prev-file</span> ()
  (interactive)
  (<span class="keyword elisp">if</span> (re-search-backward <span class="string">"^[-+ ]*Buffer: "</span> nil t 2)
      (moccur-next 1)
    (goto-char (point-max))
    (<span class="keyword elisp">if</span> (re-search-backward <span class="string">"^[-+ ]*Buffer: "</span> nil t)
        (moccur-next 1))))

(<span class="keyword">defun</span> <span class="function">moccur-mode-kill-file-internal</span> ()
  (<span class="keyword elisp">let</span> ((start-pt (<span class="keyword elisp">progn</span>
                    (re-search-backward <span class="string">"^[-+ ]*Buffer: "</span> nil t)
                    (line-beginning-position)))
        (end-pt nil))

    (forward-line 1)
    (<span class="keyword elisp">if</span> (re-search-forward moccur-buffer-heading-regexp nil t)
        (setq end-pt (line-beginning-position))
      (setq end-pt (point-max)))
    (delete-region start-pt end-pt)))

(<span class="keyword">defun</span> <span class="function">moccur-mode-kill-line-internal</span> ()
  (delete-region (line-beginning-position)
                 (+ (line-end-position) 1))

  (moccur-get-info)
  (<span class="keyword cl">when</span> (= 0 moccur-buffer-match-count)
    (moccur-mode-kill-file)))

(<span class="keyword">defun</span> <span class="function">moccur-mode-start-ee-switch-before-buffer</span> (ee line)
  (moccur-ee-start)

  (<span class="keyword elisp">if</span> (and ee
           (string-match <span class="string">"ee"</span> (buffer-name (current-buffer))))
      (moccur-switch-buffer 'ee)
    (moccur-switch-buffer 'normal))
  (goto-line line))

(<span class="keyword">defun</span> <span class="function">moccur-mode-kill-ee</span> ()
  (<span class="keyword cl">when</span> (and (string-match <span class="string">"ee"</span> (buffer-name (current-buffer)))
             (buffer-live-p (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>)))
    (kill-buffer (get-buffer <span class="string">"*ee-outline*/*Moccur*"</span>))))

(<span class="keyword">defun</span> <span class="function">moccur-kill-line</span> ()
  (interactive)
  (<span class="keyword elisp">let</span>* ((line (<span class="keyword elisp">progn</span> (end-of-line) (count-lines 1 (point))))
         (moccur-current-ee
          (<span class="keyword elisp">if</span> (string-match <span class="string">"ee"</span> (buffer-name (current-buffer)))
              t
            nil))
         (str
          (regexp-quote
           (<span class="keyword elisp">progn</span>
             (<span class="keyword elisp">save-excursion</span>
               (beginning-of-line)
               (re-search-forward <span class="string">"[<span class="negation">^</span> ]"</span> (line-end-position) t)
               (buffer-substring-no-properties
                (- (point) 1) (line-end-position)))))))

    (moccur-mode-kill-ee)
    (moccur-switch-buffer 'normal)
    (goto-char (point-min))
    (<span class="keyword elisp">if</span> (string-match <span class="string">"^[+-]"</span> str)
        (setq str (substring str 2)))
    (<span class="keyword elisp">let</span> ((buffer-read-only nil)
          (inhibit-read-only nil))
      (<span class="keyword cl">when</span> (re-search-forward str nil t)
        (line-beginning-position)
        (<span class="keyword elisp">cond</span>
         ((string-match <span class="string">"^[ ]*$"</span> str)
          ())
         ((string-match moccur-buffer-heading-regexp str)
          (moccur-mode-kill-file-internal))

         ((string-match moccur-line-number-regexp str)
          (moccur-mode-kill-line-internal))
         (t
          ()))))

    <span class="comment">;; highlight but slow..., so comment...</span>
    <span class="comment">;;(moccur-buffer-color)</span>
    (moccur-mode-start-ee-switch-before-buffer moccur-current-ee line)))

(<span class="keyword">defun</span> <span class="function">moccur-mode-kill-file</span> ()
  (interactive)
  (<span class="keyword elisp">let</span>* ((line (<span class="keyword elisp">progn</span> (end-of-line) (count-lines 1 (point))))
         (moccur-current-ee
          (<span class="keyword elisp">if</span> (string-match <span class="string">"ee"</span> (buffer-name (current-buffer)))
              t
            nil))
         (str
          (regexp-quote
           (<span class="keyword elisp">progn</span>
             (<span class="keyword elisp">save-excursion</span>
               (end-of-line)
               (re-search-backward <span class="string">"^[-+ ]*Buffer: "</span> nil t)
               (buffer-substring-no-properties
                (point) (line-end-position)))))))

    (moccur-mode-kill-ee)
    (moccur-switch-buffer 'normal)
    (goto-char (point-min))
    (<span class="keyword elisp">if</span> (string-match <span class="string">"^[+-]"</span> str)
        (setq str (substring str 2)))
    (<span class="keyword elisp">let</span> ((buffer-read-only nil)
          (inhibit-read-only nil))
      (<span class="keyword cl">when</span> (re-search-forward (regexp-quote str) nil t)
        (line-beginning-position)
        (moccur-mode-kill-file-internal)))

    <span class="comment">;; highlight but slow..., so comment...</span>
    <span class="comment">;;(moccur-buffer-color)</span>

    (moccur-mode-start-ee-switch-before-buffer moccur-current-ee line)))

(<span class="keyword">defun</span> <span class="function">moccur-mode-undo</span> ()
  (interactive)
  (<span class="keyword elisp">let</span>* ((line (<span class="keyword elisp">progn</span> (end-of-line) (count-lines 1 (point))))
         (moccur-current-ee
          (<span class="keyword elisp">if</span> (string-match <span class="string">"ee"</span> (buffer-name (current-buffer)))
              t
            nil))
         (str
          (regexp-quote
           (<span class="keyword elisp">progn</span>
             (<span class="keyword elisp">save-excursion</span>
               (end-of-line)
               (re-search-backward <span class="string">"^[-+ ]*Buffer: "</span> nil t)
               (buffer-substring-no-properties
                (point) (line-end-position)))))))

    (moccur-mode-kill-ee)
    (moccur-switch-buffer 'normal)
    (<span class="keyword elisp">if</span> (string-match <span class="string">"^[+-]"</span> str)
        (setq str (substring str 2)))
    (<span class="keyword elisp">let</span> ((buffer-read-only nil)
          (inhibit-read-only nil))
      (<span class="keyword elisp">condition-case</span> err
          (undo)
        (<span class="warning">error</span>
         ()))
      (goto-char (point-min))
      (re-search-forward (regexp-quote str) nil t))

    <span class="comment">;; highlight but slow..., so comment...</span>
    <span class="comment">;;(moccur-buffer-color)</span>

    (moccur-mode-start-ee-switch-before-buffer moccur-current-ee line)))

(<span class="keyword">defun</span> <span class="function">moccur-flush-lines</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> ((str
         (<span class="keyword elisp">progn</span>
           (<span class="keyword elisp">save-excursion</span>
             (<span class="keyword elisp">if</span> (and (not (and (boundp 'running-xemacs) running-xemacs))
                      transient-mark-mode mark-active)
                 (goto-char (region-beginning)))
             (beginning-of-line)
             (re-search-forward <span class="string">"[<span class="negation">^</span> ]"</span> nil t)
             (regexp-quote
              (buffer-substring-no-properties
               (- (point) 1) (line-end-position))))))
        (rend-str (<span class="keyword elisp">if</span> (and (not (and (boundp 'running-xemacs) running-xemacs))
                           transient-mark-mode mark-active)
                      (<span class="keyword elisp">progn</span>
                        (<span class="keyword elisp">save-excursion</span>
                          (goto-char (region-end))
                          (beginning-of-line)
                          (re-search-forward <span class="string">"[<span class="negation">^</span> ]"</span> (line-end-position) t)
                          (regexp-quote
                           (buffer-substring-no-properties
                            (- (point) 1) (line-end-position)))))
                    nil))
        (line (<span class="keyword elisp">progn</span> (<span class="keyword elisp">save-excursion</span> (end-of-line) (count-lines 1 (point)))))
        (moccur-current-ee
         (<span class="keyword elisp">if</span> (string-match <span class="string">"ee"</span> (buffer-name (current-buffer)))
             t
           nil))
        (regexp
         (read-from-minibuffer
          <span class="string">"Flush lines (containing match for regexp): "</span> nil nil nil
          'regexp-history nil t)))

    (moccur-mode-kill-ee)
    (moccur-switch-buffer 'normal)

    (goto-char (point-min))
    (<span class="keyword elisp">if</span> (string-match <span class="string">"^[+-]"</span> str)
        (setq str (substring str 2)))
    (<span class="keyword elisp">if</span> (and rend-str
             (string-match <span class="string">"^[+-]"</span> rend-str))
        (setq rend-str (substring rend-str 2)))

    (re-search-forward (regexp-quote str) nil t)
    (beginning-of-line)
    (<span class="keyword elisp">let</span> (rstart rend
                 (buffer-read-only nil)
                 (inhibit-read-only nil))
      (setq rstart (point))
      (<span class="keyword elisp">if</span> rend-str
          (setq rend (copy-marker
                      (<span class="keyword elisp">save-excursion</span>
                        (goto-char (point-min))
                        (re-search-forward (regexp-quote rend-str) nil t)
                        (end-of-line)
                        (point))))
        (setq rend (point-max-marker)))
      (goto-char rstart)
      (<span class="keyword elisp">let</span> ((<span class="keyword cl">case</span>-fold-search case-fold-search))
        (<span class="keyword elisp">save-excursion</span>
          (<span class="keyword elisp">while</span> (and (&lt; (point) rend)
                      (re-search-forward regexp rend t))
            (goto-char (line-beginning-position))
            (<span class="keyword cl">unless</span> (re-search-forward
                     moccur-buffer-heading-regexp (line-end-position) t)
              (line-beginning-position)
              (moccur-mode-kill-line-internal))))))
    (moccur-mode-start-ee-switch-before-buffer moccur-current-ee line)))

(<span class="keyword">defun</span> <span class="function">moccur-keep-lines</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> ((str
         (<span class="keyword elisp">progn</span>
           (<span class="keyword elisp">save-excursion</span>
             (<span class="keyword elisp">if</span> (and (not (and (boundp 'running-xemacs) running-xemacs))
                      transient-mark-mode mark-active)
                 (goto-char (region-beginning)))
             (beginning-of-line)
             (re-search-forward <span class="string">"[<span class="negation">^</span> ]"</span> nil t)
             (regexp-quote
              (buffer-substring-no-properties
               (- (point) 1) (line-end-position))))))
        (rend-str (<span class="keyword elisp">if</span> (and (not (and (boundp 'running-xemacs) running-xemacs))
                           transient-mark-mode mark-active)
                      (<span class="keyword elisp">progn</span>
                        (<span class="keyword elisp">save-excursion</span>
                          (goto-char (region-end))
                          (beginning-of-line)
                          (re-search-forward <span class="string">"[<span class="negation">^</span> ]"</span> (line-end-position) t)
                          (regexp-quote
                           (buffer-substring-no-properties
                            (- (point) 1) (line-end-position)))))
                    nil))
        (line (<span class="keyword elisp">progn</span> (<span class="keyword elisp">save-excursion</span> (end-of-line) (count-lines 1 (point)))))
        (moccur-current-ee
         (<span class="keyword elisp">if</span> (string-match <span class="string">"ee"</span> (buffer-name (current-buffer)))
             t
           nil))
        (regexp (read-from-minibuffer
                 <span class="string">"Flush lines (containing match for regexp): "</span> nil nil nil
                 'regexp-history nil t)))

    (moccur-mode-kill-ee)
    (moccur-switch-buffer 'normal)

    (goto-char (point-min))
    (<span class="keyword elisp">if</span> (string-match <span class="string">"^[+-]"</span> str)
        (setq str (substring str 2)))
    (<span class="keyword elisp">if</span> (and rend-str
             (string-match <span class="string">"^[+-]"</span> rend-str))
        (setq rend-str (substring rend-str 2)))

    (re-search-forward (regexp-quote str) nil t)
    (beginning-of-line)
    (<span class="keyword elisp">let</span> (rstart rend
                 (buffer-read-only nil)
                 (inhibit-read-only nil))
      (setq rstart (point))
      (<span class="keyword elisp">if</span> rend-str
          (setq rend (copy-marker
                      (<span class="keyword elisp">save-excursion</span>
                        (goto-char (point-min))
                        (re-search-forward (regexp-quote rend-str) nil t)
                        (end-of-line)
                        (point))))
        (setq rend (point-max-marker)))
      (goto-char rstart)
      (<span class="keyword elisp">let</span> ((<span class="keyword cl">case</span>-fold-search case-fold-search))
        (<span class="keyword elisp">save-excursion</span>
          (<span class="keyword elisp">while</span> (&lt; (point) rend)
            (goto-char (beginning-of-line))
            (<span class="keyword cl">unless</span> (or (string=
                         (buffer-substring-no-properties
                          (line-beginning-position) (line-end-position)) <span class="string">""</span>)
                        (<span class="keyword elisp">save-excursion</span>
                          (re-search-forward regexp (line-end-position) t)))
              (<span class="keyword cl">unless</span>
                  (re-search-forward
                   moccur-buffer-heading-regexp (line-end-position) t)
                (beginning-of-line)
                (moccur-mode-kill-line-internal)
                (forward-line -1)))
            (forward-line 1)))))
    (moccur-mode-start-ee-switch-before-buffer moccur-current-ee line)))

(<span class="keyword">defun</span> <span class="function">moccur-quit</span> ()
  (interactive)
  (<span class="keyword elisp">while</span> moccur-xdoc2txt-buffers
    (<span class="keyword cl">when</span> (buffer-live-p
           (car (car moccur-xdoc2txt-buffers)))
      (kill-buffer (car (car moccur-xdoc2txt-buffers))))
    (setq moccur-xdoc2txt-buffers (cdr moccur-xdoc2txt-buffers)))
  (setq buffer-menu-moccur nil)
  (moccur-kill-buffer nil)

  (<span class="keyword cl">when</span> (buffer-live-p moccur-current-buffer)
    (switch-to-buffer moccur-current-buffer)
    (<span class="keyword cl">when</span> moccur-windows-conf
      (set-window-configuration moccur-windows-conf)))

  <span class="comment">;; this is needed as <span class="string">"save-excursion"</span> is used in</span>
  <span class="comment">;; <span class="string">"moccur-remove-overlays-on-all-buffers"</span>, so we have to make sure the point in current</span>
  <span class="comment">;; buffer is already restored before calling <span class="string">"moccur-remove-overlays-on-all-buffers"</span></span>
  (<span class="keyword cl">when</span> moccur-buffer-position
    (goto-char moccur-buffer-position)
    (setq moccur-buffer-position nil))

  (moccur-remove-overlays-on-all-buffers))

(<span class="keyword">defun</span> <span class="function">moccur-toggle-view</span> ()
  (interactive)
  (setq moccur-view-other-window (not moccur-view-other-window)))

<span class="comment">;;;; body</span>
(<span class="keyword">defun</span> <span class="function">moccur-mode</span> (<span class="type">&amp;optional</span> ee)
  <span class="string">"Major mode for output from \\[<span class="constant important">moccur</span>].
Move point to one of the occurrences in this buffer,
then use \\[<span class="constant important">moccur-mode-goto-occurrence</span>] to move to the buffer and
line where it was found.
\\{occur-mode-map}"</span>
  (kill-all-local-variables)
  (setq buffer-read-only t)
  (setq major-mode 'moccur-mode)
  (setq mode-name <span class="string">"Moccur"</span>)
  (<span class="keyword elisp">if</span> ee
      (<span class="keyword elisp">progn</span>
        (setq mode-name <span class="string">"Moccur-ee"</span>)
        (use-local-map moccur-ee-mode-map)
        (setq moccur-ee-mode-map (moccur-set-key-ee)))
    (use-local-map moccur-mode-map)
    (setq moccur-mode-map (moccur-set-key)))
  (make-local-variable 'line-move-ignore-invisible)
  (setq line-move-ignore-invisible t)
  (<span class="keyword elisp">if</span> (not (and (boundp 'running-xemacs) running-xemacs))
      (add-to-invisibility-spec '(moccur . t)))
  (make-local-variable 'outline-regexp)
  (setq outline-regexp <span class="string">"\\(^Buffer: \\|^[ ]*[0-9]+ \\)"</span>)
  (make-local-variable 'outline-level)
  (setq outline-level 'moccur-outline-level))

(<span class="keyword">defun</span> <span class="function">moccur-grep-mode</span> ()
  <span class="string">"Major mode for output from \\[<span class="constant important">moccur-grep</span>].
Move point to one of the occurrences in this buffer,
then use \\[<span class="constant important">moccur-grep-goto</span>] to move to the buffer and
line where it was found.
\\{occur-mode-map}"</span>
  (kill-all-local-variables)
  (setq buffer-read-only t)
  (setq major-mode 'moccur-grep-mode)
  (setq mode-name <span class="string">"Moccur-grep"</span>)
  (use-local-map moccur-mode-map)
  (setq moccur-mode-map (moccur-set-key))
  <span class="comment">;; Commented out by &lt;WL&gt; (who should we disable moccur-toggle-view here?)</span>
  <span class="comment">;; (local-unset-key <span class="string">"t"</span>)</span>
  (local-set-key <span class="string">"\C-m"</span> 'moccur-grep-goto)
  (local-set-key <span class="string">"\C-c\C-c"</span> 'moccur-grep-goto)
  (make-local-variable 'line-move-ignore-invisible)
  (setq line-move-ignore-invisible t)
  (<span class="keyword elisp">if</span> (not (and (boundp 'running-xemacs) running-xemacs))
      (add-to-invisibility-spec '(moccur . t)))

  (turn-on-font-lock)

  (make-local-variable 'outline-regexp)
  (setq outline-regexp <span class="string">"\\(^Buffer: File (grep): \\)"</span>)
  (make-local-variable 'outline-level)
  (setq outline-level 'moccur-outline-level))

<span class="comment">;;; grep-buffers</span>
<span class="comment">;;(<span class="keyword">require</span> '<span class="constant">compile</span>)</span>
(<span class="keyword">defun</span> <span class="function">grep-buffers</span> ()
  <span class="string">"*Run `grep` PROGRAM to match EXPRESSION (with optional OPTIONS) \
on all visited files."</span>
  (interactive)
  (<span class="keyword elisp">save-excursion</span>
    (<span class="keyword elisp">let</span>*  ((regexp (read-from-minibuffer <span class="string">"grep all-buffer : "</span>))
            (buffers (moccur-filter-buffers (buffer-list)))
            com)
      (setq com (concat
                 grep-command <span class="string">"\""</span> regexp <span class="string">"\" "</span>))
      (<span class="keyword elisp">while</span> buffers
        (<span class="keyword elisp">if</span> (not (buffer-file-name (car buffers)))
            (setq buffers (cdr buffers))
          (<span class="keyword elisp">let</span> ((currfile (buffer-file-name (car buffers))))
            (setq buffers (cdr buffers))
            (setq com (concat
                       com <span class="string">" "</span>
                       currfile)))))
      (grep com))))

<span class="comment">;;; junk<span class="builtin">:search-buffers</span></span>
<span class="comment">;;;; variables</span>
(<span class="keyword">defface</span> <span class="variable">search-buffers-face</span>
  '((((class color)
      (background dark))
     (<span class="builtin">:background</span> <span class="string">"SkyBlue"</span> <span class="builtin">:bold</span> t <span class="builtin">:foreground</span> <span class="string">"Black"</span>))
    (((class color)
      (background light))
     (<span class="builtin">:background</span> <span class="string">"ForestGreen"</span> <span class="builtin">:bold</span> t))
    (t
     ()))
  <span class="string">"face."</span>
  <span class="builtin">:group</span> 'color-moccur
  )

(<span class="keyword">defface</span> <span class="variable">search-buffers-header-face</span>
  '((((class color)
      (background dark))
     (<span class="builtin">:background</span> <span class="string">"gray20"</span> <span class="builtin">:bold</span> t <span class="builtin">:foreground</span> <span class="string">"azure3"</span>))
    (((class color)
      (background light))
     (<span class="builtin">:background</span> <span class="string">"ForestGreen"</span> <span class="builtin">:bold</span> t))
    (t
     ()))
  <span class="string">"face."</span>
  <span class="builtin">:group</span> 'color-moccur
  )

<span class="comment">;;;; read minibuffer</span>
(<span class="keyword">defun</span> <span class="function">search-buffers-regexp-read-from-minibuf</span> ()
  (<span class="keyword elisp">let</span> (default input)
    (setq default
          (<span class="keyword elisp">if</span> (thing-at-point 'word)
              (thing-at-point 'word)
            (car regexp-history)))
    (setq input
          (read-from-minibuffer
           (<span class="keyword elisp">if</span> default
               (format <span class="string">"Search buffers regexp (default `<span class="constant important">%s</span>'): "</span>
                       default)
             <span class="string">"Search buffers regexp: "</span>)
           nil nil nil
           'regexp-history default
           color-moccur-default-ime-status))
    (<span class="keyword elisp">if</span> (and (equal input <span class="string">""</span>) default)
        (setq input default))
    input))

<span class="comment">;;;; body</span>
(<span class="keyword">defvar</span> <span class="variable">search-buffers-current-buffer</span> nil)
(<span class="keyword">defvar</span> <span class="variable">search-buffers-windows-conf</span> nil)
(<span class="keyword">defvar</span> <span class="variable">search-buffers-regexp-list</span> nil)
(<span class="keyword">defvar</span> <span class="variable">search-buffers-regexp</span> nil)
(<span class="keyword">defvar</span> <span class="variable">search-buffers-regexp-for-moccur</span> nil)

(<span class="keyword">defun</span> <span class="function">search-buffers</span> (regexp arg)
  <span class="string">"*Search string of all buffers."</span>
  (interactive (list (search-buffers-regexp-read-from-minibuf)
                     current-prefix-arg))
  (setq search-buffers-current-buffer (current-buffer))
  (setq search-buffers-windows-conf (current-window-configuration))
  (<span class="keyword elisp">save-excursion</span>
    (<span class="keyword elisp">if</span> (get-buffer <span class="string">"*Search*"</span>)  <span class="comment">; there ought to be just one of these</span>
        (kill-buffer (get-buffer <span class="string">"*Search*"</span>)))
    (<span class="keyword elisp">let</span>*  ((buffers (moccur-filter-buffers (buffer-list)))
            (occbuf (generate-new-buffer <span class="string">"*Search*"</span>))
            (regexp-lst nil) str cur-lst match
            match-text beg end lst)

      (setq buffers (sort buffers moccur-buffer-sort-method))

      (set-buffer occbuf)
      (insert <span class="string">"Search "</span> regexp <span class="string">"\n"</span>)

      (setq str regexp)
      (setq search-buffers-regexp regexp)
      (setq search-buffers-regexp-list (moccur-word-split regexp t))
      (setq regexp-lst search-buffers-regexp-list)
      (search-buffers-set-regexp-for-moccur)
      (setq lst nil)

      (<span class="keyword elisp">while</span> buffers
        (<span class="keyword elisp">if</span> (and (not arg) (not (buffer-file-name (car buffers))))
            (setq buffers (cdr buffers))
          (<span class="keyword elisp">let</span> ((currbuf (car buffers)))
            (setq cur-lst regexp-lst)
            (setq buffers (cdr buffers))
            (set-buffer currbuf)
            (setq match t)
            (setq match-text nil)
            (<span class="keyword elisp">save-excursion</span>
              (<span class="keyword elisp">while</span> (and cur-lst match)
                (goto-char (point-min))
                (setq regexp (car cur-lst))
                (setq cur-lst (cdr cur-lst))
                (<span class="keyword elisp">if</span> (re-search-forward regexp nil t)
                    (<span class="keyword elisp">progn</span>
                      (<span class="keyword elisp">if</span> (&gt; (- (match-beginning 0) 30) 0)
                          (setq beg (- (match-beginning 0) 30))
                        (setq beg 1))
                      (<span class="keyword elisp">if</span> (&lt; (+ 30 (match-end 0)) (point-max))
                          (setq end (+ 30 (match-end 0)))
                        (setq end (point-max)))
                      (setq match-text
                            (cons
                             (buffer-substring beg end)
                             match-text)))
                  (setq match nil))))
            (<span class="keyword elisp">if</span> match
                (<span class="keyword elisp">progn</span>
                  (<span class="keyword elisp">let</span>* ((linenum (count-lines (point-min)(point)))
                         (tag (format <span class="string">"\n%3d "</span> linenum))
                         fname)
                    (<span class="keyword elisp">save-excursion</span>
                      (set-buffer occbuf)
                      (<span class="keyword elisp">if</span> (buffer-file-name currbuf)
                          (setq fname (buffer-file-name currbuf))
                        (setq fname <span class="string">"Not file"</span>))
                      (insert (concat <span class="string">"Buffer: "</span> (buffer-name currbuf)
                                      <span class="string">" File: "</span> fname <span class="string">"\n"</span>))
                      (<span class="keyword elisp">while</span> match-text
                        (insert (car match-text))
                        (setq match-text (cdr match-text))
                        (insert <span class="string">" ... \n"</span>))
                      (goto-char (point-max))
                      (insert <span class="string">"\n\n"</span>))))))))
      (switch-to-buffer occbuf)
      (goto-char (point-min))
      (search-buffers-color regexp-lst)
      (setq buffer-read-only t)
      (search-buffers-view-mode 1)
      (search-buffers-next))))

<span class="comment">;;;; mode</span>
(<span class="keyword">defvar</span> <span class="variable">search-buffers-view-mode</span> nil
  <span class="string">"*Non-nil means in an search-buffers-view-mode."</span>)
(make-variable-buffer-local 'search-buffers-view-mode)
(<span class="keyword">defvar</span> <span class="variable">search-buffers-view-mode-map</span> nil <span class="string">""</span>)

(setq search-buffers-view-mode-map nil)

(or search-buffers-view-mode-map
    (<span class="keyword elisp">let</span> ((map (make-sparse-keymap)))
      (define-key map <span class="string">" "</span>
        (function search-buffers-scroll-up))
      (define-key map <span class="string">"b"</span>
        (function search-buffers-scroll-down))
      (define-key map <span class="string">"q"</span>
        (function search-buffers-exit))
      (define-key map <span class="string">"\C-m"</span>
        (function search-buffers-call-moccur))
      <span class="comment">;;(function search-buffers-goto))</span>
      (define-key map <span class="string">"p"</span>
        (function search-buffers-prev))
      (define-key map <span class="string">"n"</span>
        (function search-buffers-next))
      (define-key map <span class="string">"k"</span>
        (function search-buffers-prev))
      (define-key map <span class="string">"j"</span>
        (function search-buffers-next))
      (define-key map '[up]
        (function search-buffers-prev))
      (define-key map '[down]
        (function search-buffers-next))
      (setq search-buffers-view-mode-map map)))

(<span class="keyword cl">when</span> (boundp 'minor-mode-map-alist)
  (or (assq 'search-buffers-view-mode-map minor-mode-map-alist)
      (setq minor-mode-map-alist
            (cons (cons 'search-buffers-view-mode
                        search-buffers-view-mode-map)
                  minor-mode-map-alist))))

(<span class="keyword">defun</span> <span class="function">search-buffers-view-mode</span> (<span class="type">&amp;optional</span> arg)
  (interactive <span class="string">"P"</span>)
  (setq search-buffers-view-mode
        (<span class="keyword elisp">if</span> (null arg)
            (not search-buffers-view-mode)
          (&gt; (prefix-numeric-value arg) 0))))

<span class="comment">;;;; function of mode</span>
(<span class="keyword">defun</span> <span class="function">search-buffers-exit</span> ()
  (interactive)
  (kill-buffer (get-buffer <span class="string">"*Search*"</span>))
  (switch-to-buffer search-buffers-current-buffer)
  (set-window-configuration search-buffers-windows-conf))

(<span class="keyword">defun</span> <span class="function">search-buffers-set-regexp-for-moccur</span> ()
  <span class="string">"Make regexp for coloring up."</span>
  (<span class="keyword elisp">let</span> ((list (cdr search-buffers-regexp-list)))
    (<span class="keyword elisp">if</span> moccur-split-word
        (<span class="keyword elisp">progn</span>
          (setq search-buffers-regexp-for-moccur
                (concat
                 <span class="string">"\\("</span> (car search-buffers-regexp-list)))
          (<span class="keyword elisp">while</span> list
            (setq search-buffers-regexp-for-moccur
                  (concat search-buffers-regexp-for-moccur
                          <span class="string">"\\|"</span>
                          (car list)))
            (setq list (cdr list)))
          (setq search-buffers-regexp-for-moccur
                (concat search-buffers-regexp-for-moccur <span class="string">"\\)"</span>)))
      (setq search-buffers-regexp-for-moccur
            (car search-buffers-regexp-list)))))

(<span class="keyword">defun</span> <span class="function">search-buffers-call-moccur</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> (bufname
        (windows-conf (current-window-configuration))
        (pos (point)))
    (<span class="keyword elisp">save-excursion</span>
      (end-of-line)
      (<span class="keyword elisp">if</span> (re-search-backward moccur-buffer-heading-regexp nil t)
          (setq bufname (buffer-substring
                         (match-beginning 1)
                         (match-end 1)))
        (<span class="keyword elisp">if</span> (re-search-forward moccur-buffer-heading-regexp nil t)
            (setq bufname (buffer-substring
                           (match-beginning 1)
                           (match-end 1))))))
    (switch-to-buffer (get-buffer bufname))
    (occur-by-moccur search-buffers-regexp-for-moccur t)
    (set-buffer (get-buffer bufname))
    (setq moccur-current-buffer (get-buffer <span class="string">"*Search*"</span>))
    (setq moccur-windows-conf windows-conf)))

(<span class="keyword">defun</span> <span class="function">search-buffers-goto</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> (bufname)
    (<span class="keyword elisp">save-excursion</span>
      (beginning-of-line)
      (<span class="keyword elisp">if</span> (re-search-forward moccur-buffer-heading-regexp nil t)
          (setq bufname (buffer-substring
                         (match-beginning 1)
                         (match-end 1)))
        (<span class="keyword elisp">if</span> (re-search-backward moccur-buffer-heading-regexp nil t)
            (setq bufname (buffer-substring
                           (match-beginning 1)
                           (match-end 1)))))
      (switch-to-buffer (get-buffer bufname))
      (delete-other-windows))))

(<span class="keyword">defun</span> <span class="function">search-buffers-next</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> (bufname)
    (end-of-line)
    (<span class="keyword elisp">if</span> (re-search-forward moccur-buffer-heading-regexp nil t)
        (<span class="keyword elisp">progn</span>
          (switch-to-buffer-other-window
           (get-buffer (buffer-substring-no-properties
                        (match-beginning 1) (match-end 1))))
          (switch-to-buffer-other-window (get-buffer <span class="string">"*Search*"</span>))
          (beginning-of-line)))
    (recenter)))

(<span class="keyword">defun</span> <span class="function">search-buffers-prev</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> (bufname)
    (beginning-of-line)
    (<span class="keyword elisp">if</span> (re-search-backward moccur-buffer-heading-regexp nil t)
        (<span class="keyword elisp">progn</span>
          (switch-to-buffer-other-window
           (get-buffer (buffer-substring-no-properties
                        (match-beginning 1) (match-end 1))))
          (switch-to-buffer-other-window (get-buffer <span class="string">"*Search*"</span>))
          (beginning-of-line)))))

(<span class="keyword">defun</span> <span class="function">search-buffers-scroll-up</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> (bufname)
    (scroll-up)
    (end-of-line)
    (<span class="keyword elisp">if</span> (re-search-forward moccur-buffer-heading-regexp nil t)
        (<span class="keyword elisp">progn</span>
          (switch-to-buffer-other-window
           (get-buffer (buffer-substring-no-properties
                        (match-beginning 1) (match-end 1))))
          (switch-to-buffer-other-window (get-buffer <span class="string">"*Search*"</span>))
          (beginning-of-line)))))

(<span class="keyword">defun</span> <span class="function">search-buffers-scroll-down</span> ()
  (interactive)
  (<span class="keyword elisp">let</span> (bufname)
    (scroll-down)
    (beginning-of-line)
    (<span class="keyword elisp">if</span> (re-search-backward moccur-buffer-heading-regexp nil t)
        (<span class="keyword elisp">progn</span>
          (switch-to-buffer-other-window
           (get-buffer (buffer-substring-no-properties
                        (match-beginning 1) (match-end 1))))
          (switch-to-buffer-other-window (get-buffer <span class="string">"*Search*"</span>))
          (beginning-of-line)))))

<span class="comment">;;; color</span>
(<span class="keyword">defun</span> <span class="function">search-buffers-color</span> (regexp-lst)
  (<span class="keyword elisp">save-excursion</span>
    (<span class="keyword elisp">let</span> (ov lst)
      (setq lst regexp-lst)
      (<span class="keyword elisp">while</span> lst
        (goto-char (point-min))
        (<span class="keyword elisp">while</span> (re-search-forward
                (car lst) nil t)
          (<span class="keyword elisp">progn</span>
            (setq ov (make-overlay (match-beginning 0)
                                   (match-end 0)))
            (overlay-put ov 'face 'search-buffers-face)
            (overlay-put ov 'priority 0)))
        (setq lst (cdr lst)))

      (goto-char (point-min))
      (<span class="keyword elisp">while</span> (re-search-forward
              <span class="string">"^Buffer: "</span> nil t)
        (<span class="keyword elisp">progn</span>
          (setq ov (make-overlay (match-beginning 0)
                                 (line-end-position)))
          (overlay-put ov 'face 'search-buffers-header-face)
          (overlay-put ov 'priority 0))))))

(<span class="keyword">provide</span> '<span class="constant">color-moccur</span>)
<span class="comment">;;; end</span>
<span class="comment">;;; color-moccur.el ends here</span></pre></div><div class="wrapper close"></div></div><div class="footer"><hr /><span class="translation bar"><br />  <a href="https://www.emacswiki.org/emacs?action=translate;id=color-moccur.el;missing=de_es_fr_it_ja_ko_pt_ru_se_uk_zh" rel="nofollow" class="translation new">Add Translation</a></span><div class="edit bar"><a accesskey="c" class="comment local edit" href="https://www.emacswiki.org/emacs/Comments_on_color-moccur.el">Talk</a> <a class="edit" accesskey="e" title="Click to edit this page" rel="nofollow" href="https://www.emacswiki.org/emacs?action=edit;id=color-moccur.el">Edit this page</a> <a class="history" rel="nofollow" href="https://www.emacswiki.org/emacs?action=history;id=color-moccur.el">View other revisions</a> <a href="https://www.emacswiki.org/emacs?action=admin;id=color-moccur.el" rel="nofollow" class="admin">Administration</a></div><div class="time">Last edited 2013-08-24 12:00 UTC by <a href="https://www.emacswiki.org/emacs/AlexSchroeder" class="author" title="178-83-163-103.dynamic.hispeed.ch">AlexSchroeder</a> <a rel="nofollow" href="https://www.emacswiki.org/emacs?action=browse;diff=2;id=color-moccur.el" class="diff">(diff)</a></div><div style="float:right; margin-left:1ex;">
<!-- Creative Commons License -->
<a class="licence" href="https://creativecommons.org/licenses/GPL/2.0/"><img alt="CC-GNU GPL" style="border:none" src="/pics/cc-GPL-a.png" /></a>
<!-- /Creative Commons License -->
</div>

<!--
<rdf:RDF xmlns="http://web.resource.org/cc/"
 xmlns:dc="http://purl.org/dc/elements/1.1/"
 xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <license rdf:resource="https://creativecommons.org/licenses/GPL/2.0/" />
  <dc:type rdf:resource="http://purl.org/dc/dcmitype/Software" />
</Work>

<License rdf:about="https://creativecommons.org/licenses/GPL/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
   <requires rdf:resource="http://web.resource.org/cc/SourceCode" />
</License>
</rdf:RDF>
-->

<p class="legal">
This work is licensed to you under version 2 of the
<a href="https://www.gnu.org/">GNU</a> <a href="/GPL">General Public License</a>.
Alternatively, you may choose to receive this work under any other
license that grants the right to use, copy, modify, and/or distribute
the work, as long as that license imposes the restriction that
derivative works have to grant the same rights and impose the same
restriction. For example, you may choose to receive this work under
the
<a href="https://www.gnu.org/">GNU</a>
<a href="/FDL">Free Documentation License</a>, the
<a href="https://creativecommons.org/">CreativeCommons</a>
<a href="https://creativecommons.org/licenses/sa/1.0/">ShareAlike</a>
License, the XEmacs manual license, or
<a href="/OLD">similar licenses</a>.
</p>
<p class="legal" style="padding-top: 0.5em">Please note our <a href="Privacy">Privacy Statement</a>.</p>
</div>
</body>
</html>
